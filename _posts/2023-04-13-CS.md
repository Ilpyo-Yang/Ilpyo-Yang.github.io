---
title: CS
author: Rosie Yang
date: 2023-04-13
category: cs
layout: post
---

## Computer Science
> Device Hardware - Operating System 운영체제 - Applications - Use

**File system 파일시스템**  
<span style="background-color:#fff5b1">OS에서 파일을 저장하는 트리구조의 저장체계</span>를 말합니다. 파일과 디렉토리로 구분할 수 있습니다.  
절대 경로는 루트 디렉토리를 기준으로 하는 경로를 말합니다. 반면, 상대 경로는 현재 있는 디렉토리를 기준으로 타깃 파일까지의 경로를 말합니다.

**터미널**  
Window - CMD window, Window Terminal  
Console = Terminal = CMD창

<br><br>

## 소프트웨어 개발 방법론
### 객체 지향 방법론
**객체지향 설계 원칙 (= SOILD)**  
> 5대 설계원칙: SRP, OCP, LSP, ISP, DIP

<span style="background-color:#fff5b1">SRP(Single Responsibility Principle), 단일 책임 원칙</span>  
한 클래스는 하나의 책임만 가져야 한다는 원칙입니다.  
아래 코드에서도 볼 수 있듯이 사용자와 관련된 로직과 이메일 발송에 대한 로직을 따로 분리해서 class화 하는 것이 바람직합니다. 단 하나의 책임만 가질 수 있도록 코드를 분리해서 작성하도록 합니다.
```kotlin
class User {
    fun register() { }
}
class EmailSender {
    fun sendEmail() { }
}
```
<span style="background-color:#fff5b1">OCP(Open/Closed principle), 개방-폐쇄 원칙</span>  
소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다는 원칙입니다.  
```Rectangle``` 클래스와 ```AreaCalculator```는 둘 다 ```Double``` 리턴 타입을 반환하는 ```calculateArea()``` 메서드는 사용합니다. 따라서 인터페이스로 묶어서  
```kotlin
interface Shape {
    fun calculateArea(): Double
}

class Rectangle(val width: Double, val height: Double) : Shape {
    override fun calculateArea(): Double {
        return width * height
    }
}

class AreaCalculator {
    fun calculateArea(shapes: List<Shape>): Double {
        var area = 0.0
        for (shape in shapes) {
            area += shape.calculateArea()
        }
        return area
    }
}
```
<span style="background-color:#fff5b1">LSP(Liskov Substitution Principle), 리스코프 치환 원칙</span>  
프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 합니다.  
```kotlin

```
<span style="background-color:#fff5b1">ISP(Interface Segregation Principle), 인터페이스 분리 원칙</span>  
특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다는 원칙으로 큰 덩어리의 인터페이스들은 구체적이고 작은 단위들로 분리시킴으로써 클라이언트들이 꼭 필요한 메서드들만 이용할 수 있게 합니다.  
```kotlin

```
<span style="background-color:#fff5b1">DIP(Dependency Inversion Principle), 의존관계 역전 원칙</span>  
프로그래머는 추상화에 의존해야지 구체화에 의존하면 안된다는 원칙입니다.  
```kotlin

```

<br><br>

### DDD(Domain-Driven Design)

![ddd.png](/assets/gitbook/post_images/architecture/ddd.png)

도메인 주도 설계는 소프트웨어의 존재 가치는 사용자의 사용에 있다는 생각에서 비롯되어 <span style="background-color:#fff5b1">비즈니스 도메인을 중심</span>으로 고려한 설계 방식입니다. 즉, 사용자가 원하는 목적에 맞게 사용할 수 있는 소프트웨어가 기술보다 우선순위에 두고 고민할 필요성이 있다는 점에서 시작됩니다. 사용자의 관점에서 정해지는 부분이기 때문에 도메인은 관점에 따라 그 수가 달라질 수 있습니다. 하지만 DDD를 사용하므로써 개발자는 단순히 기술영역에만 국한되지 않고 도메인 영역까지 사고하는 생각의 범주를 더 넓힐 수 있습니다.  
<span style="background-color:#fff5b1">바운디드 컨텍스트</span>란 모델이 구현되는 곳이자 각각의 분리된 소프트웨어 산출물이 나오게 되는 곳입니다. 유비쿼터스 언어로 표현해 공동 작업을 하는 팀원과 유관 부서 간의 혼동을 피하는 것을 기본으로 합니다.

**반 버논의 도메인 분류**
+ 메인(핵심) 도메인
+ 서브 도메인
    + <span style="background-color:#fff5b1">핵심 서브 도메인</span>
        + 다른 경쟁자와 차별화를 만들 수 있는 비즈니스 영역
        + 높은 우선순위를 갖는 전략적 투자 영역
        + 가장 큰 투자가 필요한 곳
    + <span style="background-color:#fff5b1">지원 서브 도메인</span>
        + 맞춤 개발이 필요한 영역
        + 핵심 서브 도메인의 성공을 위한 중요한 영역
    + <span style="background-color:#fff5b1">일반 서브 도메인</span>
        + 기존 제품 구매를 통해 바로 충족시킬 수 있는 영역
        + 핵심/지원 서브도메인이 할당된 팀에서 직접 구현 가능

<br>

**DDD 파일시스템**

****

[Domain-Driven Design Simplified.](https://medium.com/@jaysonmulwa/domain-driven-design-simplified-a03c732401c9)  
[도메인 주도 설계에서의 전략적 설계](https://engineering-skcc.github.io/msa/DDD-StrategicDesign/)

