---
title: ğŸ“– LeetCode Top Interview 150 (ì§„í–‰ì¤‘)
author: Rosie Yang
date: 2023-08-25
category: job
layout: post
---

+ [637. Average of Levels in Binary Tree](/job/2023/08/25/Leetcode.html#637-average-of-levels-binary-tree)
+ [199. Binary Tree Right Side View](/job/2023/08/25/Leetcode.html#199-binary-tree-right-side-view)
+ [230. Kth Smallest Element in a BST](/job/2023/08/25/Leetcode.html#230-kth-smallest-element-in-a-bst)
+ [530. Minimum Absolute Difference in BST](/job/2023/08/25/Leetcode.html#530-minimum-absolute-difference-in-bst)
+ [33. Search in Rotated Sorted Array](/job/2023/08/25/Leetcode.html#33-search-in-rotated-sorted-array)
+ [153. Find Minimum in Rotated Sorted Array](/job/2023/08/25/Leetcode.html#153-find-minimum-in-rotated-sorted-array)
+ [162. Find Peak Element](/job/2023/08/25/Leetcode.html#162-find-peak-element)
+ [148. Sort List](/job/2023/08/25/Leetcode.html#148-sort-list)
+ [242. Valid Anagram](/job/2023/08/25/Leetcode.html#242-valid-anagram)
+ [383. Ransom Note](/job/2023/08/25/Leetcode.html#383-ransom-note)
+ [219. Contains Duplicate II](/job/2023/08/25/Leetcode.html#219-contains-duplicate-2)
+ [1. Two Sum](/job/2023/08/25/Leetcode.html#1-two-sum)
+ [150. Evaluate Reverse Polish Notation](/job/2023/08/25/Leetcode.html#150-evaluate-reverse-polish-notation)
+ [155. Min Stack](/job/2023/08/25/Leetcode.html#155-min-stack)
+ [3. Longest Substring Without Repeating Characters](/job/2023/08/25/Leetcode.html#3-longest-substring-without-repeating-characters)
+ [209. Minimum Size Subarray Sum](/job/2023/08/25/Leetcode.html#209-minimum-size-subarray-sum)
+ [167. Two Sum II - Input Array Is Sorted](/job/2023/08/25/Leetcode.html#167-two-sum-2-input-array-is-sorted)
+ [125. Valid Palindrome](/job/2023/08/25/Leetcode.html#125-valid-palindrome)
+ [169. Majority Element](/job/2023/08/25/Leetcode.html#169-majority-element)
+ [80. Remove Duplicates from Sorted Array II](/job/2023/08/25/Leetcode.html#80-remove-duplicates-from-sorted-array-2)
+ [26. Remove Duplicates from Sorted Array](/job/2023/08/25/Leetcode.html#26-remove-duplicates-from-sorted-array)
+ [27. Remove Element](/job/2023/08/25/Leetcode.html#27-remove-element)
+ [88. Merge Sorted Array](/job/2023/08/25/Leetcode.html#88-merge-sorted-array)

<br>

```
// ì‘ì„± ì–‘ì‹
### 
#### 1. ë¬¸ì œ
[ë¬¸ì œ URL]()
#### 2. ë‚˜ì˜ í’€ì´
##### ì‹œë„ 1
``` java
\```
#### 3. ë‹¤ë¥¸ ì‚¬ëŒì˜ í’€ì´
```java
\```
#### 4. ìƒê°í•´ë³´ê¸°
---
<br>
```

### 637. Average of Levels in Binary Tree
#### 1. ë¬¸ì œ
[ë¬¸ì œ URL](https://leetcode.com/problems/average-of-levels-in-binary-tree/?envType=study-plan-v2&envId=top-interview-150)
+

#### 2. ë‚˜ì˜ í’€ì´
##### ì‹œë„ 1

``` java

```
#### 3. ë‹¤ë¥¸ ì‚¬ëŒì˜ í’€ì´

```java

```
#### 4. ìƒê°í•´ë³´ê¸°


---
<br>


### 199. Binary Tree Right Side View
#### 1. ë¬¸ì œ
[ë¬¸ì œ URL](https://leetcode.com/problems/binary-tree-right-side-view/?envType=study-plan-v2&envId=top-interview-150)
+ ì´ì§„ íŠ¸ë¦¬ì˜ ì˜¤ë¥¸ìª½ì—ì„œ ì‹œì‘í•˜ì—¬ íŠ¸ë¦¬ë¥¼ ë³´ë©´ì„œ ë§¨ ì˜¤ë¥¸ìª½ì— ìˆëŠ” ë…¸ë“œ(ê° ë ˆë²¨ì—ì„œ ê°€ì¥ ì˜¤ë¥¸ìª½ì— ìˆëŠ” ë…¸ë“œ)ë“¤ì˜ ê°’ì„ ìœ„ì—ì„œ ì•„ë˜ë¡œ ìˆœì„œëŒ€ë¡œ ë°˜í™˜í•´ì•¼ í•©ë‹ˆë‹¤.

#### 2. ë‚˜ì˜ í’€ì´
##### ì‹œë„ 1
ë¬¸ì œë¥¼ ë³´ê³  ê°€ì¥ ë¨¼ì € ë“  ìƒê°ì€ ìš°ì„  ê° ë…¸ë“œ ì¸µì—ì„œ ê°€ì¥ ì˜¤ë¥¸ìª½ ê°’ì„ listì— ì €ì¥í•˜ê³  ë¦¬í„´í•˜ë©´ ë˜ì§€ ì•Šì„ê¹Œë¼ëŠ” ìƒê°ì´ì—ˆìŠµë‹ˆë‹¤. 
ê·¸ëŸ°ë° ë¬´ì‘ì • í’€ì—ˆì„ ë•Œ ì™¼ìª½ ë…¸ë“œì—ì„œ ì˜¤ë¥¸ìª½ ë³´ë‹¤ ê¸´ ê²½ìš°ì˜ ìœ„ì¹˜ë¥¼ ì°¾ì•„ì„œ ë°˜í™˜í•˜ëŠ” ê²ƒì´ ìƒê°ë³´ë‹¤ ë³µì¡í•´ì„œ ë¬¸ì œì—ì„œ ì œì‹œí•œ ì´ì§„ íŠ¸ë¦¬ë¥¼ ë” ì´ìš©í•´ì•¼ê² ë‹¤ëŠ” ìƒê°ì´ ë“¤ì—ˆìŠµë‹ˆë‹¤.

``` java
class Solution {
    int h=0;
    List<Integer> list = new ArrayList<>();
    public hList<Integer> rightSideView(TreeNode root) {
        deepth(root);
        getRight(root);
        if(h==list.size()) return list;
        else{
            
        }
    }

    public void deepth(TreeNode root){
        if(root==null) return; 
        deepth(root.left);
        h++;
        deepth(root.right);
    }

    public void getRight(TreeNode root){
        if(root==null) return; 
        list.add(root.val);
        deepth(root.right);
    }
}
```

##### ì‹œë„ 2
ì´ì§„ íŠ¸ë¦¬ë¥¼ ì´ìš©í•œ ë°©ë²•ìœ¼ë¡œ ì‹œë„í–ˆì§€ë§Œ ì‹¤íŒ¨í•œ í’€ì´ì…ë‹ˆë‹¤.
+ ì—¬ê¸°ì„œ ë³´ë©´, ë…¸ë“œì˜ ë†’ì´ ```h```ë¥¼ ì´ìš©í–ˆëŠ”ë°, ```rightSideView(root.right);```ë¥¼ ë‹¤ ëŒê³ ë‚˜ì„œ ```h++;```ê°€ ì§„í–‰ë˜ê¸° ë•Œë¬¸ì— ì™¼ìª½ê³¼ ì˜¤ë¥¸ìª½ ë…¸ë“œ ì¸µì˜ ì°¨ì´ê°€ ìƒê¸°ê²Œ ë©ë‹ˆë‹¤.
+ ë”°ë¼ì„œ ë¶„ë¦¬í•´ì„œ ë…¸ë“œì˜ ì¸µì„ ìœ ì§€í•˜ëŠ” ë°©ë²•ì„ ì´ìš©í•´ì•¼ í•©ë‹ˆë‹¤.

```java
class Solution {
    int h=0;
    List<Integer> list = new ArrayList<>();
    public List<Integer> rightSideView(TreeNode root) {
        if(root==null) return null;
        if(h==list.size()) list.add(root.val);

        rightSideView(root.right);
        h++;
        rightSideView(root.left);

        return list;
    }
}
```

#### 3. ë‹¤ë¥¸ ì‚¬ëŒì˜ í’€ì´
ì—¬ê¸°ì„œ ì£¼ì˜ê¹Šê²Œ ë³¸ ë¶€ë¶„ì€ ```rightView```ì—ì„œ ì¬ê·€ë¥¼ ëŒ ë•Œ ì˜¤ë¥¸ìª½ ë…¸ë“œë¶€í„° ì‹¤í–‰í•˜ëŠ” ê²ƒì„ ì•Œ ìˆ˜ ìˆìŠµë‹ˆë‹¤. 
ì´ì „ì— ìµœì†Œê°’ ë˜ëŠ” kë²ˆì§¸ë¡œ ì‘ì€ ìˆ˜ë¥¼ êµ¬í•˜ê¸° ìœ„í•´ ì¤‘íšŒìˆœíšŒë¥¼ ì‚¬ìš©í•˜ë˜ ë°©ì‹ê³¼ ë°˜ëŒ€ë¡œ ì´ìš©í•  ìˆ˜ ìˆë‹¤ëŠ” ê²ƒì„ ì•Œ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
```java
public class Solution {
    public List<Integer> rightSideView(TreeNode root) {
        List<Integer> result = new ArrayList<Integer>();
        rightView(root, result, 0);
        return result;
    }
    
    public void rightView(TreeNode curr, List<Integer> result, int currDepth){
        if(curr == null){
            return;
        }
        if(currDepth == result.size()){
            result.add(curr.val);
        }
        
        rightView(curr.right, result, currDepth + 1);
        rightView(curr.left, result, currDepth + 1);
    }
}
```

#### 4. ìƒê°í•´ë³´ê¸°
ì–´ë µê²Œ ìƒê°í•˜ì§€ ì•Šê³  ê¸°ì¡´ì— ì•„ëŠ” ë‚´ìš©ì„ ì–´ë–»ê²Œ í•˜ë©´ í™œìš©í•´ì„œ í’€ì´í•  ìˆ˜ ìˆì„ê¹Œ ê³ ë¯¼í•˜ëŠ” ë°©ë²•ì„ ìµíˆëŠ” ê²ƒì´ ì¤‘ìš”í•©ë‹ˆë‹¤.
ì´ ë¬¸ì œì—ì„œ ì˜¤ë¥¸ìª½ ë·°ë¡œ ì‚´í´ë³´ëŠ” ë¬¸ì œì˜€ì§€ë§Œ ì˜ˆë¥¼ ë“¤ì–´ ì™¼ìª½ ë·°ë¡œ ë™ì¼í•œ ë¬¸ì œë¥¼ í’€ì´í•˜ê²Œ ëœë‹¤ë©´ ì½”ë“œë¥¼ ë‹¤ìŒê³¼ ê°™ì´ ì‘ì„±í•  ìˆ˜ ìˆì„ ê²ƒì…ë‹ˆë‹¤.
```java
public class Solution {
    public List<Integer> leftSideView(TreeNode root) {
        List<Integer> result = new ArrayList<Integer>();
        rightView(root, result, 0);
        return result;
    }
    
    public void leftView(TreeNode curr, List<Integer> result, int currDepth){
        if(curr == null){
            return;
        }
        if(currDepth == result.size()){
            result.add(curr.val);
        }

        leftView(curr.left, result, currDepth + 1);
        leftView(curr.right, result, currDepth + 1);
    }
}
```

---
<br>

### 230. Kth Smallest Element in a BST
#### 1. ë¬¸ì œ
[ë¬¸ì œ URL](https://leetcode.com/problems/kth-smallest-element-in-a-bst/?envType=study-plan-v2&envId=top-interview-150)
+ ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬ (BST)ì˜ ë£¨íŠ¸ì™€ ì •ìˆ˜ ```k```ê°€ ì£¼ì–´ì¡Œì„ ë•Œ, ì´ì§„ íŠ¸ë¦¬ì˜ ëª¨ë“  ë…¸ë“œ ê°’ ì¤‘ì—ì„œ ```k```ë²ˆì§¸ë¡œ ì‘ì€ ê°’ì„ ì°¾ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

#### 2. ë‚˜ì˜ í’€ì´
##### ì‹œë„ 1
BSTì˜ ëª¨ë“  ë…¸ë“œ ê°’ì„ ì˜¤ë¦„ì°¨ìˆœìœ¼ë¡œ ë°©ë¬¸í•˜ëŠ” ì¤‘ìœ„ ìˆœíšŒë¥¼ ì‚¬ìš©í•˜ì—¬ ```k```ë²ˆì§¸ë¡œ ì‘ì€ ê°’ì„ ì°¾ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
+ [530. Minimum Absolute Difference in BST](/job/2023/08/25/Leetcode.html#530-minimum-absolute-difference-in-bst) ë¬¸ì œë¥¼ í‘¼ ì´í›„ë¼ì„œ ì‰½ê²Œ ì ‘ê·¼í•  ìˆ˜ ìˆì—ˆìŠµë‹ˆë‹¤.

``` java
class Solution {
    List<Integer> list = new ArrayList<>();
    public int kthSmallest(TreeNode root, int k) {
        if(root==null){
            Collections.sort(list);
            if(list.size()<k) return 0;
            else return list.get(k-1);
        } 
        list.add(root.val);
        kthSmallest(root.left, k);
        kthSmallest(root.right, k);

        Collections.sort(list);
        if(list.size()<k) return 0;
        else return list.get(k-1);
    }
}
```
ì´ê²ƒë„ í†µê³¼ ì½”ë“œì´ê¸´ í•˜ì§€ë§Œ ë” ê¹”ë”í•˜ê²Œ ì¤‘ë³µ ì½”ë“œë¥¼ ì •ë¦¬í•´ë³´ê¸°ë¡œ í–ˆìŠµë‹ˆë‹¤.
``` java
class Solution {
    List<Integer> list = new ArrayList<>();
    public int kthSmallest(TreeNode root, int k) {
        if(root==null){
            return getAnswer(list, k);  
        } 
        list.add(root.val);
        kthSmallest(root.left, k);
        kthSmallest(root.right, k);
        return getAnswer(list, k);        
    }

    public int getAnswer(List<Integer> list, int k) {
        Collections.sort(list);
        if(list.size()<k) return 0;
        else return list.get(k-1);

    }
}
```
ì œê°€ í‘¼ í’€ì´ì˜ ì‹œê°„ë³µì¡ë„ì™€ ê³µê°„ë³µì¡ë„ëŠ” ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤.
+ ì‹œê°„ë³µì¡ë„: O(n log n)
+ ê³µê°„ë³µì¡ë„: O(n)

#### 3. ë‹¤ë¥¸ ì‚¬ëŒì˜ í’€ì´
ì´ í’€ì´ëŠ” ì‹œê°„ë³µì¡ë„ë©´ì—ì„œ ì†í•´ë¥¼ ë´¤ì§€ë§Œ ë²ˆë²ˆíˆ ```sort```ì²˜ë¦¬ë¥¼ í•´ì£¼ëŠ” ì œ ì½”ë“œì™€ëŠ” ë‹¬ë¦¬ ë§ˆì§€ë§‰ì—ì„œë§Œ ```return```ìœ¼ë¡œ ```k```ë²ˆì§¸ë¡œ ì‘ì€ ê°’ì„ ê°€ì§€ê³  ì˜¤ëŠ” ê²ƒì„ ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
ë°”ë¡œ ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬ë¼ëŠ” ìë£Œêµ¬ì¡°ì˜ íŠ¹ì„±ì„ ê°€ì§€ê³  ìˆê¸° ë•Œë¬¸ì…ë‹ˆë‹¤.
+ ì‹œê°„ë³µì¡ë„: O(n)
+ ê³µê°„ë³µì¡ë„: O(n)

```java
class Solution {
    List<Integer> list=new ArrayList<>();
    public int kthSmallest(TreeNode root, int k) {
        if(root==null)return 0;
        help(root,k);
        return list.get(k-1);
    }
    public void help(TreeNode root,int k)
    {
        if(root==null)return;
        help(root.left,k);
        list.add(root.val);
        if(list.size()==k)return;
        help(root.right,k);
    }
}
```

#### 4. ìƒê°í•´ë³´ê¸°
ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬ë¼ëŠ” ìë£Œêµ¬ì¡°ì˜ íŠ¹ì„±ì„ ê°€ì§€ê³  ìˆë‹¤ëŠ” ì ì„ ê³ ë ¤í•´ì„œ ì œ ì½”ë“œ(ì‹œë„ 2)ì˜ ë¶€ë¶„ì„ ìˆ˜ì •í•´ë³´ê² ìŠµë‹ˆë‹¤.
ì´ì „ ì½”ë“œì˜ ë¬¸ì œì ì€ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤.
+ ì£¼ì–´ì§„ ì½”ë“œì—ì„œëŠ” ì¤‘ë³µ ë…¸ë“œ ê°’ì„ í¬í•¨í•˜ì—¬ ëª¨ë“  ë…¸ë“œ ê°’ì„ ë¦¬ìŠ¤íŠ¸ì— ì¶”ê°€í•˜ê³  ìˆìœ¼ë¯€ë¡œ ì˜¬ë°”ë¥¸ ì¤‘ìœ„ ìˆœíšŒê°€ ì•„ë‹™ë‹ˆë‹¤.
+ ëª¨ë“  ë…¸ë“œ ê°’ì„ ì¤‘ë³µìœ¼ë¡œ ë¦¬ìŠ¤íŠ¸ì— ì¶”ê°€í•˜ê³  ë‚˜ì¤‘ì— ì •ë ¬í•˜ì—¬ kë²ˆì§¸ ê°’ì„ ì°¾ìœ¼ë ¤ëŠ” ê²ƒì€ ë¹„íš¨ìœ¨ì ì…ë‹ˆë‹¤.

ì•„ë˜ì™€ ê°™ì€ ì½”ë“œë¥¼ ì‚¬ìš©í•˜ë©´, ```count```ë¡œ ìˆ˜ë¥¼ ì¡°ì •í•  ìˆ˜ ìˆìœ¼ë©°, ëª¨ë“  ë…¸ë“œë¥¼ ê²€ìƒ‰í•˜ê³  ì •ë ¬í•˜ì§€ ì•Šì•„ë„ ì¤‘ê°„ì— ì •ì§€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. 
ì´ì§„íƒìƒ‰íŠ¸ë¦¬ ë¬¸ì œì—ì„œ ì´ëŸ° ìŠ¤íƒ€ì¼ë¡œì˜ êµ¬í˜„ë°©ë²•ì„ ìµí˜€ë‘˜ í•„ìš”ê°€ ìˆìŠµë‹ˆë‹¤.
```java
public class Solution {
    int result;
    int count;

    public int kthSmallest(TreeNode root, int k) {
        count = 0;
        inOrderTraversal(root, k);
        return result;
    }

    private void inOrderTraversal(TreeNode node, int k) {
        if (node == null) return;
        
        inOrderTraversal(node.left, k);
        count++;
        
        if (count == k) {
            result = node.val;
            return;
        }
        
        inOrderTraversal(node.right, k);
    }
}

```

---
<br>

### 530. Minimum Absolute Difference in BST
#### 1. ë¬¸ì œ
[ë¬¸ì œ URL](https://leetcode.com/problems/minimum-absolute-difference-in-bst/?envType=study-plan-v2&envId=top-interview-150)
+ ì£¼ì–´ì§„ ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬(BST)ì˜ ì„œë¡œ ë‹¤ë¥¸ ë‘ ë…¸ë“œ ê°’ ì¤‘ ìµœì†Œ ì ˆëŒ€ ì°¨ì´ë¥¼ ë°˜í™˜í•˜ëŠ” ë¬¸ì œì…ë‹ˆë‹¤. ì¦‰, BSTì—ì„œ ê°€ì¥ ê°€ê¹Œìš´ ê°’ì˜ ì°¨ì´ë¥¼ ì°¾ëŠ” ë¬¸ì œì…ë‹ˆë‹¤.
+ ì˜ˆë¥¼ ë“¤ì–´, ```[1,null,5,3]``` rootê°€ ì…ë ¥ëœë‹¤ë©´, ê·¸ ìµœì†Œ ì ˆëŒ€ ì°¨ì´ëŠ” ```2```ê°€ ë©ë‹ˆë‹¤.

#### 2. ë‚˜ì˜ í’€ì´
##### ì‹œë„ 1
+ ë¬¸ì œë¥¼ ì²˜ìŒì— ì˜ëª» ì•Œê³  ì ‘ê·¼í•´ì„œ ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. 
  + ìˆœì„œëŒ€ë¡œ valê°€ ì™¼ìª½ì—ì„œ ì˜¤ë¥¸ìª½ìœ¼ë¡œ ë“¤ì–´ê°€ê¸° ë•Œë¬¸ì— ê°€ì¥ ì™¼ìª½ ë…¸ë“œì™€ ê°€ì¥ ì˜¤ë¥¸ìª½ ë…¸ë“œì˜ ì°¨ì´ë§Œ ê³ ë ¤í•˜ë©´ ëœë‹¤ê³  ìƒê°í–ˆìŠµë‹ˆë‹¤.
  + í•˜ì§€ë§Œ, ```[5,4,7]``` rootì—ì„œ ìµœì†Œ ì ˆëŒ€ ì°¨ì´ëŠ” ```1```ë¡œ ì¸ì ‘ ë…¸ë“œ ê°’ì˜ ì°¨ì´ë¥¼ êµ¬í•˜ëŠ” ë¬¸ì œì…ë‹ˆë‹¤. ~~ë†’ì´ê°€ ì•„ë‹ˆë¼..!!~~

```java
class Solution {
    int left=0, right=0;
    public int getMinimumDifference(TreeNode root) {
        TreeNode lroot = root;
        TreeNode rroot = root;
        while(lroot.left!=null){
            lroot = lroot.left;
            left++;
        }
        while(rroot.right!=null){
            rroot = rroot.right;
            right++;
        }
        return Math.abs(left-right);
    }
}
```

##### ì‹œë„ 2
ê·¸ëŸ¼ ë‹¤ì‹œ ì¸ì ‘ ë…¸ë“œ ê°’ì˜ ì°¨ì´ë¥¼ êµ¬í•˜ëŠ” ë°©ì‹ìœ¼ë¡œ í’€ì´í•´ë´¤ìŠµë‹ˆë‹¤. ì´ë ‡ê²Œ ì¬ê·€ì  í’€ì´ë¥¼ í•˜ë©´ ë˜ì§€ ì•Šì„ê¹Œ í•˜ëŠ” ìƒê°ì—ì„œ ë§Œë“¤ì–´ë´¤ëŠ”ë° ì‹œê°„ì´ˆê³¼ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.
+ ì¤‘ìœ„ ìˆœíšŒ ë°©ë²•ì´ì§€ë§Œ ì¤‘ê°„ê°’ì„ ë¦¬í„´í•˜ê¸° ë•Œë¬¸ì— ìµœì¢…ì ìœ¼ë¡œ ìµœì†Œ ì°¨ì´ ê°’ì´ ì•„ë‹Œ ê°’ì´ ë‚˜ì™”ìŠµë‹ˆë‹¤.
+ ```[0,null,2236,1277,2776,519]``` ê°’ì—ì„œ ì›í•˜ëŠ” ì •ë‹µì€ ```519```ì˜€ë‹¤ëŠ” ì ì…ë‹ˆë‹¤.
  + ì¦‰, 519ëŠ” ìœ„ì˜ ë…¸ë“œ ê°’ 1277ê³¼ì˜ ì°¨ì´ ì™¸ì—ë„ 0ê³¼ì˜ ì°¨ì´ë„ ê³„ì‚°ë˜ì–´ì•¼ í•œë‹¤ëŠ”ê²Œ í•µì‹¬ì…ë‹ˆë‹¤. 
  + ì¼ë‹¨ ì‹œë„ 2ì—ì„œ 2ê°€ì§€ ë¬¸ì œê°€ ìˆìŒì„ ì•Œê²Œ ë˜ì—ˆìŠµë‹ˆë‹¤.
    + ```root.val-prev```ì—ì„œ ì ˆëŒ€ê°’ ì²˜ë¦¬ê°€ í•„ìš”ì—†ìŠµë‹ˆë‹¤. ì¤‘ìœ„ìˆœíšŒì´ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤.
    + ê·¸ë¦¬ê³  ì´ˆê¸°ê°’ ì„¤ì •ì´ ì˜ëª»ë˜ì–´ ìˆìŠµë‹ˆë‹¤. ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬ì—ì„œ ëª¨ë“  ë…¸ë“œì˜ ê°’ì´ -10000 ì´ìƒì´ë¼ëŠ” ì œì•½ ì¡°ê±´ì´ ì£¼ì–´ì¡Œì„ ë•Œ, prev ê°’ì„ -10000ìœ¼ë¡œ ì„¤ì •í•˜ë©´ ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬ì˜ ë£¨íŠ¸ ë…¸ë“œë¥¼ ë°©ë¬¸í•˜ê¸° ì „ì—ë„ ì´ì „ ë…¸ë“œì™€ í˜„ì¬ ë…¸ë“œ ê°„ì˜ ì°¨ì´ë¥¼ êµ¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

```java
class Solution {
  int min=10000, prev=0;
  public int getMinimumDifference(TreeNode root) {
    if(root==null) return min;
    getMinimumDifference(root.left);
    if(prev!=0) min=Math.min(min, Math.abs(root.val-prev));
    prev=root.val;
    getMinimumDifference(root.right);

    return min;
  }
}
```

##### ì‹œë„ 3
ìœ„ì— ê³ ë¯¼í•œ ë‚´ìš©ë“¤ì„ ë°˜ì˜í•œ í†µê³¼ ì½”ë“œì…ë‹ˆë‹¤.
+ ì‹œê°„ë³µì¡ë„: O(n)
+ ê³µê°„ë³µì¡ë„: O(n)

```java
class Solution {
  int prev = -100000, min = 100000;
  public int getMinimumDifference(TreeNode root) {
    if(root==null) return min;
    getMinimumDifference(root.left);
    min=Math.min(min, root.val-prev);
    prev=root.val;
    getMinimumDifference(root.right);
    return min;
  }
}
```

#### 3. ë‹¤ë¥¸ ì‚¬ëŒì˜ í’€ì´
```void inOrderTraversal``` ë©”ì†Œë“œë¡œ ë°˜í™˜ ê°’ì€ ì—†ì§€ë§Œ ```min``` ê°’ì„ ì°¾ì„ ìˆ˜ ìˆê²Œ í•˜ëŠ” ë°©ì‹ì…ë‹ˆë‹¤.
+ ì¤‘ìœ„ ìˆœíšŒë¥¼ ì‚¬ìš©í•˜ë©´ BSTì˜ ë…¸ë“œë¥¼ ì˜¤ë¦„ì°¨ìˆœìœ¼ë¡œ ë°©ë¬¸í•˜ë¯€ë¡œ ì¸ì ‘í•œ ë‘ ë…¸ë“œ ê°„ì˜ ì°¨ì´ë¥¼ ê³„ì‚°í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. 
+ ì¤‘ìœ„ ìˆœíšŒë¥¼ ì‚¬ìš©í•˜ì§€ ì•Šê³  ë‹¤ë¥¸ ë°©ì‹ìœ¼ë¡œ íŠ¸ë¦¬ë¥¼ ìˆœíšŒí•˜ë©´ ì •ë ¬ëœ ìˆœì„œëŒ€ë¡œ ë…¸ë“œë¥¼ ë°©ë¬¸í•  ìˆ˜ ì—†ìœ¼ë¯€ë¡œ ìµœì†Œ ì°¨ì´ë¥¼ ê³„ì‚°í•˜ê¸° ì–´ë ¤ì›Œì§‘ë‹ˆë‹¤.

```java
class Solution {
    int min = Integer.MAX_VALUE;
    TreeNode prev = null;
    
    public int getMinimumDifference(TreeNode root) {
        inOrderTraversal(root);
        return min;
    }

    private void inOrderTraversal(TreeNode node) {
        if (node == null) {
            return;
        }

        inOrderTraversal(node.left);

        if (prev != null) {
            min = Math.min(min, Math.abs(node.val - prev.val));
        }
        prev = node;

        inOrderTraversal(node.right);
    }
}
```

#### 4. ìƒê°í•´ë³´ê¸°
ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬(BST)ì— ëŒ€í•˜ì—¬ ë‹¤ì‹œ ì •ë¦¬í•´ë³´ë©´ ë‹¤ìŒ íŠ¹ì§•ë“¤ì„ ê°€ì§€ê³  ìˆìŠµë‹ˆë‹¤.
+ ëª¨ë“  ë…¸ë“œëŠ” ìµœëŒ€ ë‘ ê°œì˜ ìì‹ ë…¸ë“œë¥¼ ê°€ì§ˆ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
+ ì™¼ìª½ ì„œë¸ŒíŠ¸ë¦¬ì˜ ëª¨ë“  ë…¸ë“œì˜ ê°’ì€ ë¶€ëª¨ ë…¸ë“œì˜ ê°’ë³´ë‹¤ ì‘ìŠµë‹ˆë‹¤.
+ ì˜¤ë¥¸ìª½ ì„œë¸ŒíŠ¸ë¦¬ì˜ ëª¨ë“  ë…¸ë“œì˜ ê°’ì€ ë¶€ëª¨ ë…¸ë“œì˜ ê°’ë³´ë‹¤ í½ë‹ˆë‹¤.
 
---
<br>

### 33. Search in Rotated Sorted Array
#### 1. ë¬¸ì œ
[ë¬¸ì œ URL](https://leetcode.com/problems/search-in-rotated-sorted-array/?envType=study-plan-v2&envId=top-interview-150)
#### 2. ë‚˜ì˜ í’€ì´
##### ì‹œë„ 1
ì´ ë¬¸ì œ ì—­ì‹œ ì‹œê°„ë³µì¡ë„ë¥¼ ```O(log n)```ë¡œ ê³ ë ¤í•´ì•¼ í•˜ëŠ” ë°©ì‹ì´ë¼ ë‹¤ìŒ í•´ê²°ë°©ë²•ì€ ì í•©í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
+ ì‹œê°„ë³µì¡ë„: O(n)
+ ê³µê°„ë³µì¡ë„: O(n)

``` java
class Solution {
    public int search(int[] nums, int target) {
        List<Integer> list = new ArrayList<>();
        for(int i:nums){
            list.add(i);
        }
        int index = list.indexOf(target);
        if(index==-1) return -1;
        else return index;
    }
}
```

##### ì‹œë„ 2
ì´ì§„ê²€ìƒ‰ì„ ì´ìš©í•œ ë°©ë²•ìœ¼ë¡œ ë‹¤ì‹œ ì‹œë„í–ˆìŠµë‹ˆë‹¤. ```left```ê°€ ```right```ë³´ë‹¤ ì‘ê±°ë‚˜ ê°™ì€ ë™ì•ˆ ë°˜ë³µí•©ë‹ˆë‹¤.
+ ì¤‘ê°„ ì¸ë±ìŠ¤ ê³„ì‚°: mid ë³€ìˆ˜ì— leftì™€ rightì˜ ì¤‘ê°„ ê°’ì¸ (left + right) / 2ë¥¼ í• ë‹¹í•©ë‹ˆë‹¤.
+ ì¤‘ê°„ ê°’ê³¼ íƒ€ê²Ÿ ê°’ ë¹„êµ: nums[mid]ê°€ targetê³¼ ê°™ìœ¼ë©´ midë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.
  + ì¤‘ê°„ ê°’ì´ ì™¼ìª½ ë¶€ë¶„ ë°°ì—´ì— ì†í•  ë•Œ:
    + íƒ€ê²Ÿì´ ì™¼ìª½ ë¶€ë¶„ ë°°ì—´ì— ì†í•˜ë©´, right ê°’ì„ mid - 1ë¡œ ì—…ë°ì´íŠ¸í•˜ì—¬ ì˜¤ë¥¸ìª½ì„ ì¢í™ë‹ˆë‹¤.
    + ê·¸ë ‡ì§€ ì•Šìœ¼ë©´, left ê°’ì„ mid + 1ë¡œ ì—…ë°ì´íŠ¸í•˜ì—¬ ì™¼ìª½ì„ ì¢í™ë‹ˆë‹¤.
  + ì¤‘ê°„ ê°’ì´ ì˜¤ë¥¸ìª½ ë¶€ë¶„ ë°°ì—´ì— ì†í•  ë•Œ:
    + íƒ€ê²Ÿì´ ì˜¤ë¥¸ìª½ ë¶€ë¶„ ë°°ì—´ì— ì†í•˜ë©´, left ê°’ì„ mid + 1ë¡œ ì—…ë°ì´íŠ¸í•˜ì—¬ ì™¼ìª½ì„ ì¢í™ë‹ˆë‹¤.
    + ê·¸ë ‡ì§€ ì•Šìœ¼ë©´, right ê°’ì„ mid - 1ë¡œ ì—…ë°ì´íŠ¸í•˜ì—¬ ì˜¤ë¥¸ìª½ì„ ì¢í™ë‹ˆë‹¤.
+ íƒìƒ‰ ì‹¤íŒ¨: ë°˜ë³µë¬¸ì„ ë¹ ì ¸ë‚˜ì˜¤ë©´, íƒ€ê²Ÿ ê°’ì„ ì°¾ì§€ ëª»í•œ ê²ƒì´ë¯€ë¡œ -1ì„ ë°˜í™˜í•©ë‹ˆë‹¤.

ì‹œê°„ë³µì¡ë„ì™€ ê³µê°„ë³µì¡ë„
+ ì‹œê°„ë³µì¡ë„: O(log n)
+ ê³µê°„ë³µì¡ë„: O(n)

```java
class Solution {
    public int search(int[] nums, int target) {
        int left = 0, right = nums.length - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] == target) {
                return mid;
            } else if (nums[mid] >= nums[left]) {
                if (target >= nums[left] && target < nums[mid]) {
                    right = mid - 1;
                } else {
                    left = mid + 1;
                }
            } else {
                if (target <= nums[right] && target > nums[mid]) {
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            }
        }
        return -1;
    }
}

```

#### 3. ë‹¤ë¥¸ ì‚¬ëŒì˜ í’€ì´
ì´ì§„ê²€ìƒ‰ì„ ì´ìš©í•œ í’€ì´ëŠ” ì œ í’€ì´ì™€ ê±°ì˜ ìœ ì‚¬í–ˆì–´ì„œ ë‹¤ë¥¸ í’€ì´ë¥¼ ì°¾ì•„ë´¤ìŠµë‹ˆë‹¤. ì´ ë¬¸ì œ ì—­ì‹œ ì‹œê°„ë³µì¡ë„ë¥¼ ```O(log n)```ë¡œ ê³ ë ¤í•´ì•¼ í•˜ëŠ” ë°©ì‹ì´ë¼ ë‹¤ìŒ í•´ê²°ë°©ë²•ì€ ì í•©í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
í•˜ì§€ë§Œ ì‹œê°„ë³µì¡ë„ë¥¼ ê³ ë ¤í•˜ì§€ ì•ŠëŠ” ì„ ì—ì„œ ì‚¬ì‹¤ ```target```ë§Œ ì°¾ìœ¼ë©´ ë˜ê¸° ë•Œë¬¸ì— ì´ë ‡ê²Œ ëª¨ë‘ ë¹„êµí•œ í’€ì´ë„ ìˆì—ˆìŠµë‹ˆë‹¤.
+ ì‹œê°„ë³µì¡ë„: O(n)
+ ê³µê°„ë³µì¡ë„: O(n)

```java
class Solution {
  public int search(int[] nums, int target) {
    int n = nums.length ;
    for( int i = 0 ; i< n ; i++){
      if( nums[i]==target ){
        return i ;
      }
    }
    return -1;
  }
}
```

#### 4. ìƒê°í•´ë³´ê¸°
ì¼ë°˜ì ìœ¼ë¡œ ì´ì§„ íƒìƒ‰ì€ ì •ë ¬ëœ ë°°ì—´ì—ì„œ ì‚¬ìš©ë˜ë©°, ì •ë ¬ë˜ì§€ ì•Šì€ ë°°ì—´ì—ì„œ ì‚¬ìš©í•˜ëŠ” ê²ƒì€ ì ì ˆí•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. í•˜ì§€ë§Œ, ì´ ë¬¸ì œì—ì„œëŠ” ì£¼ì–´ì§„ ë°°ì—´ì´ íšŒì „ëœ ìƒíƒœì´ê¸° ë•Œë¬¸ì—, ë°°ì—´ì˜ ì¼ë¶€ë¶„ì´ ì •ë ¬ë˜ì–´ ìˆê³ , ë‚˜ë¨¸ì§€ ë¶€ë¶„ì´ íšŒì „ëœ ìƒíƒœì…ë‹ˆë‹¤. ì´ëŸ¬í•œ ìƒí™©ì—ì„œë„ ì´ì§„ íƒìƒ‰ì„ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.  

ì‹œë„ 2 í’€ì´ì—ì„œëŠ” íšŒì „ëœ ë¶€ë¶„ ë°°ì—´ì„ ì°¾ê¸° ìœ„í•´ ```nums[mid] >= nums[left]```ì™€ ê°™ì€ ì¡°ê±´ë¬¸ì„ ì‚¬ìš©í•˜ì˜€ìŠµë‹ˆë‹¤. ì´ ì¡°ê±´ë¬¸ì€ ì¤‘ê°„ ê°’ì´ ì™¼ìª½ ë¶€ë¶„ ë°°ì—´ì— ì†í•˜ëŠ”ì§€ ì˜¤ë¥¸ìª½ ë¶€ë¶„ ë°°ì—´ì— ì†í•˜ëŠ”ì§€ë¥¼ íŒë³„í•©ë‹ˆë‹¤. 
ì´ëŸ¬í•œ ë°©ì‹ìœ¼ë¡œ ì´ì§„ íƒìƒ‰ì„ ì´ìš©í•˜ì—¬ íšŒì „ëœ ë°°ì—´ì—ì„œë„ ì›í•˜ëŠ” ê°’ì„ ì°¾ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

---
<br>

### 153. Find Minimum in Rotated Sorted Array
#### 1. ë¬¸ì œ
[ë¬¸ì œ URL](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/?envType=study-plan-v2&envId=top-interview-150)
+ ë¬¸ì œì—ì„œ rotatedë¼ê³  í•´ì„œ í—·ê°ˆë¦´ìˆ˜ë„ ìˆì§€ë§Œ ê²°êµ­ì—ì„œ ì£¼ì–´ì§„ ë°°ì—´ ```nums```ì—ì„œ ê°€ì¥ ì‘ì€ ìš”ì†Œì˜ ì¸ë±ìŠ¤ë¥¼ ë°˜í™˜í•˜ëŠ” ë¬¸ì œì…ë‹ˆë‹¤.
+ ê°€ì¥ í° ìš”ì†Œë¥¼ êµ¬í•˜ëŠ” 162ë²ˆ ë¬¸ì œ ì°¸ê³ 

#### 2. ë‚˜ì˜ í’€ì´
##### ì‹œë„ 1
ì´ë ‡ê²Œ í’€ë©´ ì•„ì£¼ ê°„ë‹¨í•˜ì§€ë§Œ ì‹œê°„ë³µì¡ë„ë¥¼ ```O(log n)```ë¡œ ê³ ë ¤í•´ì•¼ í•˜ëŠ” ì¡°ê±´ì´ ìˆìŒì— ì£¼ì˜í•´ì•¼ í•©ë‹ˆë‹¤.
+ ì‹œê°„ë³µì¡ë„: O(n)
+ ê³µê°„ë³µì¡ë„: O(1)

``` java
class Solution {
    public int findMin(int[] nums) {
        for(int i=0; i<nums.length-1; i++){
            if(nums[i]>nums[i+1]) return nums[i+1];
        }
        return nums[0];
    }
}
```

##### ì‹œë„ 2
ì´ì§„ê²€ìƒ‰ì„ ì´ìš©í•œ ë°©ë²•ìœ¼ë¡œ ë‹¤ì‹œ ì‹œë„í–ˆìŠµë‹ˆë‹¤.
+ ``left``ì™€ ```right``` ë³€ìˆ˜ë¥¼ ì‚¬ìš©í•˜ì—¬ ë°°ì—´ì˜ ì™¼ìª½ê³¼ ì˜¤ë¥¸ìª½ ëì ì„ ë‚˜íƒ€ë‚´ê³ , ```mid``` ë³€ìˆ˜ë¥¼ ì‚¬ìš©í•˜ì—¬ ì¤‘ê°„ ì§€ì ì„ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤.
+ ```while```ë¬¸ì—ì„œëŠ” ```left```ì™€ ```right```ê°€ ê°™ì•„ì§ˆ ë•Œê¹Œì§€ ë°˜ë³µí•˜ë©°, ```mid``` ì§€ì ì˜ ê°’ì´ ```mid+1``` ì§€ì ì˜ ê°’ë³´ë‹¤ í° ê²½ìš° ```mid+1``` ì§€ì ì˜ ê°’ì„ ë°˜í™˜í•˜ê³ , ```mid``` ì§€ì ì˜ ê°’ì´ ```mid-1``` ì§€ì ì˜ ê°’ë³´ë‹¤ í° ê²½ìš° ```mid``` ì§€ì ì˜ ê°’ì„ ë°˜í™˜í•©ë‹ˆë‹¤.
+ ê·¸ë¦¬ê³  ```mid``` ì§€ì ì˜ ê°’ì´ ë°°ì—´ì˜ ì²« ë²ˆì§¸ ìš”ì†Œë³´ë‹¤ í° ê²½ìš° ```left```ë¥¼ ```mid+1```ë¡œ ì—…ë°ì´íŠ¸í•˜ê³ , ê·¸ë ‡ì§€ ì•Šì€ ê²½ìš° ```right```ë¥¼ ```mid-1```ë¡œ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤.
+ ê²°êµ­ ```left``` ë³€ìˆ˜ê°€ ê°€ë¦¬í‚¤ëŠ” ìœ„ì¹˜ê°€ íšŒì „ëœ ë°°ì—´ì—ì„œ ê°€ì¥ ì‘ì€ ìš”ì†Œì˜ ìœ„ì¹˜ê°€ ë©ë‹ˆë‹¤.

ì‹œê°„ë³µì¡ë„ì™€ ê³µê°„ë³µì¡ë„
+ ì‹œê°„ë³µì¡ë„: O(n)
+ ê³µê°„ë³µì¡ë„: O(n)

```java
class Solution {
  public int findMin(int[] nums) {
    int n = nums.length;
    if(n==1) return nums[0];

    int left = 0, right = n-1;
    if(nums[right]>nums[0]) return nums[0];

    while(left<right){
      int mid = left + (right-left)/2;
      if(nums[mid]>nums[mid+1]) return nums[mid+1];
      if(nums[mid-1]>nums[mid]) return nums[mid];
      if(nums[mid]>nums[0]){
        left = mid+1;
      } else {
        right = mid-1;
      }
    }
    return nums[left];
  }
}

```

#### 3. ë‹¤ë¥¸ ì‚¬ëŒì˜ í’€ì´
ê°™ì€ ë°©ë²•ì´ì§€ë§Œ ë³€ìˆ˜ë‚˜ í’€ì´ê°€ ë” ê¹”ë”í•˜ê³  ë³´ê¸° ì¢‹ì•„ì„œ ```Solutions```ì— ìˆëŠ” í’€ì´ë¥¼ ê°€ì§€ê³  ì™”ìŠµë‹ˆë‹¤. 

```java
class Solution {
    public int findMin(int[] nums) {
        int left = 0;
        int right = nums.length - 1;

        while (left < right) {
            int mid = left + (right - left) / 2;

            if (nums[mid] > nums[right]) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }

        return nums[left];
    }
}
```

#### 4. ìƒê°í•´ë³´ê¸°
ì´ì§„ ê²€ìƒ‰ì„ ì‚¬ìš©í•˜ì—¬ íšŒì „ëœ ì •ë ¬ëœ ë°°ì—´ì—ì„œ ê°€ì¥ ì‘ì€ ìš”ì†Œë¥¼ ì°¾ì•˜ìŠµë‹ˆë‹¤. ì´ì§„ ê²€ìƒ‰ì„ ì‚¬ìš©í•  ë•ŒëŠ” ë°°ì—´ì˜ ì¤‘ê°„ ê°’ì„ ì°¾ëŠ” ë°©ë²•ê³¼, ì´ ê°’ì„ ì°¾ì€ í›„ì— ì–´ëŠ ë¶€ë¶„ì„ ëŒ€ìƒìœ¼ë¡œ ê²€ìƒ‰ì„ ì§„í–‰í• ì§€ë¥¼ ê²°ì •í•˜ëŠ” ë°©ë²•ì„ ì •í™•íˆ ì´í•´í•´ì•¼ í•©ë‹ˆë‹¤.

---
<br>

### 162. Find Peak Element
#### 1. ë¬¸ì œ
[ë¬¸ì œ URL](https://leetcode.com/problems/find-peak-element/description/?envType=study-plan-v2&envId=top-interview-150)
+ ```Peek``` ìš”ì†Œì˜ ì¸ë±ìŠ¤ë¥¼ ë°˜í™˜í•˜ëŠ” ë¬¸ì œì…ë‹ˆë‹¤.
+ ë¬¸ì œì—ì„œëŠ” ```O(log n)```ì˜ ì‹œê°„ë³µì¡ë„ë¥¼ ì‚¬ìš©í•˜ë¼ê³  í–ˆìŒìœ¼ë¡œ ëª¨ë“  ìš”ì†Œë¥¼ í™•ì¸í•˜ëŠ” ë°©ì‹ë³´ë‹¤ íš¨ìœ¨ì ì¸ ì•Œê³ ë¦¬ì¦˜ì„ ì‚¬ìš©í•´ì•¼ í•©ë‹ˆë‹¤.

#### 2. ë‚˜ì˜ í’€ì´
##### ì‹œë„ 1
í‰ì†ŒëŒ€ë¡œ ê°„ë‹¨í•˜ê²Œ ```Arrays.sort(nums);``` ì •ë ¬ í›„ ```List```ë¥¼ ì´ìš©í•´ ê°€ì¥ í° ìš”ì†Œì˜ ì¸ë±ìŠ¤ ê°’ì„ êµ¬í•˜ëŠ” ë°©ì‹ìœ¼ë¡œ í’€ì´í–ˆìŠµë‹ˆë‹¤.
+ ì‹œê°„ë³µì¡ë„ê°€ ë¬¸ì œì—ì„œ ì œì‹œí•œ í¬ê¸°ë³´ë‹¤ í½ë‹ˆë‹¤.
+ ì‹œê°„ë³µì¡ë„: O(n log n)
+ ê³µê°„ë³µì¡ë„: O(n)

``` java
class Solution {
    public int findPeakElement(int[] nums) {
        List<Integer> list = new ArrayList<>();
        for(int i:nums){
            list.add(i);
        }
        Arrays.sort(nums);
        int answer = list.indexOf(nums[nums.length-1]);
        return answer;
    }
}
```

#### ì‹œë„ 2
ë¬¸ì œì˜ ì˜ë„ëŒ€ë¡œ ì‹œê°„ë³µì¡ë„ë¥¼ ì¤„ì´ê¸° ìœ„í•´ì„œëŠ” ì´ì§„íƒìƒ‰(Binary Search) ë°©ì‹ì„ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. í•˜ì§€ë§Œ ì´ë ‡ê²Œ í’€ì´í–ˆì„ ë•ŒëŠ” ì‹œê°„ì´ˆê³¼ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.
```java
class Solution {
   public int findPeakElement(int[] nums) {
      int left=0, right=nums.length-1;
      int middle=(nums[left]+nums[right])/2;
      while(left<right){
         if(nums[middle-1]<nums[middle] && nums[middle+1]<nums[middle]) return middle;
         if(nums[middle-1]<nums[middle]) left=middle+1;
         else right=middle-1;
      }
      return left; 
   }
}
```

#### 3. ë‹¤ë¥¸ ì‚¬ëŒì˜ í’€ì´
ë¦¬í„´ê°’ì´ ```0```ì´ ë‚˜ì˜¬ ìˆ˜ ë°–ì— ì—†ëŠ” ê°’ê³¼ ìˆœì„œëŒ€ë¡œ ì •ë ¬ë˜ì–´ ìˆì–´ ë§ˆì§€ë§‰ ìš”ì†Œê°€ peakì¸ ê²½ìš°ë¥¼ ë¨¼ì € ì œì™¸í•©ë‹ˆë‹¤.
ê·¸ë¦¬ê³  whileë¬¸ìœ¼ë¡œ ì´ì§„íƒìƒ‰ì„ ìˆ˜í–‰í•©ë‹ˆë‹¤. ì¤‘ê°„ê°’ ì–‘ì˜†ì˜ ê°’ë³´ë‹¤ ì¤‘ê°„ê°’ì´ í° ê²½ìš°ëŠ” ì¤‘ê°„ê°’ì„ retruní•©ë‹ˆë‹¤. 
```java
class Solution {
    public int findPeakElement(int[] nums) {
        int n = nums.length;
        if(n == 1 || nums[0] > nums[1]) return 0;
        if(nums[n - 1] > nums[n - 2]) return n - 1;
        int l = 0;
        int r = n - 1;
        while(l <= r)
        {
            int m = (l + r)/2;
            int minus = m == 0 ? Integer.MIN_VALUE : nums[m-1];
            int plusUltra = m == n - 1 ? Integer.MIN_VALUE : nums[m+1];
            if(minus < nums[m] && plusUltra < nums[m]) return m;
            if(minus < nums[m]) l = m + 1;
            else r = m - 1;
        }
        return l;
    }
}
```

---
<br>

### 148. Sort List
#### 1. ë¬¸ì œ
[ë¬¸ì œ URL](https://leetcode.com/problems/sort-list/description/?envType=study-plan-v2&envId=top-interview-150)
+ ì£¼ì–´ì§„ ```ListNode```ë¥¼ ì˜¤ë¦„ì°¨ìˆœìœ¼ë¡œ ì •ë ¬í•´ì„œ ```ListNode```ë¡œ ë¦¬í„´í•˜ëŠ” ë¬¸ì œì…ë‹ˆë‹¤.
+ ```ListNode```ëŠ” ```val```ì™€ ```ListNode```ë¡œ êµ¬ì„±ë˜ì–´ ìˆìŠµë‹ˆë‹¤.

```
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
```

#### 2. ë‚˜ì˜ í’€ì´
##### ì‹œë„ 1
ì£¼ì–´ì§„ ListNodeì˜ ê°’ë“¤ì„ ì°¾ì•„ ìˆœì„œëŒ€ë¡œ Listë¡œ ì •ë ¬í•˜ê³  ì´ ê°’ë“¤ì„ ê°€ì§€ê³  ìƒˆë¡œìš´ ListNodeë¥¼ ìƒì„±í•˜ëŠ” ê³¼ì •ìœ¼ë¡œ í’€ì´í–ˆìŠµë‹ˆë‹¤.  
+ í•˜ì§€ë§Œ ë¬¸ì œì˜ ```Follow up```ì—ì„œëŠ” ê³µê°„ë³µì¡ë„ê°€ ```O(1)```ì¸ ë°©ë²•ìœ¼ë¡œ í‘¸ëŠ” ë°©ì‹ì€ ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.
+ ì‹œê°„ë³µì¡ë„: O(n log n)
+ ê³µê°„ë³µì¡ë„: O(n)

```java
class Solution {
    public ListNode sortList(ListNode head) {
        if(head==null) return head;
        
        List<Integer> list = new ArrayList<>();
        while(head!=null){
            list.add(head.val);
            head = head.next;
        }
        Collections.sort(list);
        Collections.reverse(list);

        ListNode answer = new ListNode();
        for(int i=0; i<list.size(); i++){
            if(i==0) answer = new ListNode(list.get(i));
            else answer = new ListNode(list.get(i), answer);
        }
        return answer;
    }
}
```

#### 3. ë‹¤ë¥¸ ì‚¬ëŒì˜ í’€ì´
ê³µê°„ë³µì¡ë„ê°€ ```O(1)```ê°€ ë‚˜ì˜¤ëŠ” í’€ì´ì…ë‹ˆë‹¤. ì—°ê²° ë¦¬ìŠ¤íŠ¸ë¥¼ ë³‘í•© ì •ë ¬ë¡œ ì •ë ¬í•˜ëŠ” í•¨ìˆ˜ì…ë‹ˆë‹¤.  
+ ```dummy```ë¡œ ê°’ì´ ```0```ì´ê³ , next ë…¸ë“œê°€ ì£¼ì–´ì§„ ```head```ì¸ ë…¸ë“œë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
+ ê·¸ë¦¬ê³  ë…¸ë“œ ë°°ì—´í˜•íƒœì¸ ```sublists```, ```sublist_tail```ì„ ë§Œë“¤ê³ , í•˜ìœ„ ë¦¬ìŠ¤íŠ¸(sublist)ì˜ í¬ê¸°ë¥¼ 1, 2, 4, 8, ... ë“±ìœ¼ë¡œ ì¦ê°€ì‹œí‚¤ë©´ì„œ, ì—°ê²° ë¦¬ìŠ¤íŠ¸ë¥¼ ë¶„í• í•˜ê³  ë³‘í•©í•©ë‹ˆë‹¤.
+ ì¶”ê°€ì ì¸ ë°°ì—´ì„ ì‚¬ìš©í•˜ì§€ ì•Šê³ , ì£¼ì–´ì§„ ì—°ê²° ë¦¬ìŠ¤íŠ¸ ë‚´ì—ì„œ ì •ë ¬ì„ ìˆ˜í–‰í•˜ë¯€ë¡œ, ê³µê°„ ë³µì¡ë„ëŠ” ```O(n)```ì…ë‹ˆë‹¤.
  + ```sublists```ì™€ ```sublists_tail```ì€ ì¶”ê°€ì ì¸ ë°°ì—´ì…ë‹ˆë‹¤.
  + í•˜ì§€ë§Œ ì´ ë°°ì—´ë“¤ì˜ í¬ê¸°ëŠ” ìƒìˆ˜ê°’ì¸ 2ë¡œ ê³ ì •ë˜ì–´ ìˆìœ¼ë©°, ì…ë ¥ ë¦¬ìŠ¤íŠ¸ì˜ í¬ê¸°ì™€ëŠ” ë¬´ê´€í•©ë‹ˆë‹¤.
  + ë”°ë¼ì„œ ì…ë ¥ ë¦¬ìŠ¤íŠ¸ì˜ í¬ê¸°ì— ë¹„ë¡€í•˜ëŠ” ê³µê°„ì„ ì¶”ê°€ë¡œ ì‚¬ìš©í•˜ì§€ ì•Šê³ , ìƒìˆ˜ í¬ê¸°ì˜ ê³µê°„ë§Œì„ ì‚¬ìš©í•˜ë¯€ë¡œ, ê³µê°„ ë³µì¡ë„ëŠ” ```O(1)```ì´ ë©ë‹ˆë‹¤.

```java
public ListNode sortList(ListNode head) {
  ListNode dummy = new ListNode(0);
  dummy.next = head;

  ListNode [] sublists = new ListNode[2];
  ListNode [] sublists_tail = new ListNode[2];

  // Grab sublists of size 1, then 2, then 4, etc, until fully merged
  for (int steps = 1;; steps *= 2) {
    // Record the progress of the current pass into a single semi sorted list by updating
    // the next of the previous node (or the dummy on the first loop)
    ListNode prev = dummy;

    // Keep track of how much is left to process on this pass of the list
    ListNode remaining = prev.next;

    int num_loops = 0;
    for (; null != remaining; ++num_loops) {
      // Split 2 sublists of steps length from the front
      for (int i = 0; i < 2; ++i) {
        sublists[i] = remaining;
        sublists_tail[i] = null;
        for (int j = 0; null != remaining && j < steps; ++j) {
          sublists_tail[i] = remaining;
          remaining = remaining.next;
        }
        // Ensure the subslist (if one was made) is terminated
        if (null != sublists_tail[i]) {
          sublists_tail[i].next = null;
        }
      }

      // We have two sublists of (upto) length step that are sorted, merge them onto the end into a single list of (upto) step * 2
      while (null != sublists[0] && null != sublists[1]) {
        if (null == sublists[1] || sublists[0].val <= sublists[1].val) {
          prev.next = sublists[0];
          sublists[0] = sublists[0].next;
        } else {
          prev.next = sublists[1];
          sublists[1] = sublists[1].next;
        }
        prev = prev.next;
      }   

      // One list has been finished, attach what ever is left of the other to the end
      if (null != sublists[0]) {
        prev.next = sublists[0];
        prev = sublists_tail[0];
      } else {
        prev.next = sublists[1];
        prev = sublists_tail[1];
      }
    }

    // If the entire list was full processed in a single loop, it means we've completely sorted the list and are done
    if (1 >= num_loops) {
      return dummy.next;
    }
  }
}
```

ë‹¤ë¥¸ í’€ì´ëŠ” ì—°ê²° ë¦¬ìŠ¤íŠ¸ì˜ ìš”ì†Œë¥¼ ë°°ì—´ì— ì €ì¥í•œ ë‹¤ìŒ ë°°ì—´ì„ ì •ë ¬í•˜ê³  ì •ë ¬ëœ ë°°ì—´ì˜ ê°’ì„ ì—°ê²° ë¦¬ìŠ¤íŠ¸ì— ì—…ë°ì´íŠ¸í–ˆìŠµë‹ˆë‹¤. ```Arrays.sort(arr);```ë¡œ ì •ë ¬í•˜ëŠ” ë°©ì‹ì´ ì œ í’€ì´ì™€ ìœ ì‚¬í–ˆìŠµë‹ˆë‹¤.

+ ì‹œê°„ë³µì¡ë„: O(n log n)
+ ê³µê°„ë³µì¡ë„: O(n)
  
```java
class Solution {
    public ListNode sortList(ListNode head) {
        int count = 0;
        ListNode temp = head;
        while(temp!=null){
            count++;
            temp = temp.next;
        }
        int[] arr = new int[count];
        temp = head;
        count = 0;
        while(temp!=null){
            arr[count++] = temp.val;
            temp = temp.next;
        }
        Arrays.sort(arr);
        temp = head;
        count = 0;
        while(temp!=null){
            temp.val = arr[count++];
            temp = temp.next;
        }
        return head;
    }
}
```

#### 4. ìƒê°í•´ë³´ê¸°
ì¶”ê°€ì ì¸ ë°°ì—´ì„ ì‚¬ìš©í•˜ì§€ ì•Šê³ , ì£¼ì–´ì§„ ì—°ê²° ë¦¬ìŠ¤íŠ¸ ë‚´ì—ì„œ ì •ë ¬ì„ ìˆ˜í–‰í•´ ê³µê°„ë³µì¡ë„ë¥¼ ì‘ê²Œ ë§Œë“¤ ìˆ˜ ìˆë‹¤ëŠ” ê²ƒì„ ì•Œê²Œ ë˜ì—ˆìŠµë‹ˆë‹¤. ìƒìˆ˜ í¬ê¸°ì˜ ê³µê°„ë§Œì„ ì‚¬ìš©í•˜ëŠ” ê²½ìš°, ì…ë ¥ í¬ê¸°ê°€ ì–´ë–»ê²Œ ë³€í•˜ë”ë¼ë„ ì¶”ê°€ì ì¸ ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ì´ ì¼ì •í•˜ê²Œ ìœ ì§€ë©ë‹ˆë‹¤. 

---
<br>

### 242. Valid Anagram
#### 1. ë¬¸ì œ
[ë¬¸ì œ URL](https://leetcode.com/problems/valid-anagram/?envType=study-plan-v2&envId=top-interview-150)
+ ì´ ë¬¸ì œëŠ” ì£¼ì–´ì§€ëŠ” ë‘ ê°œì˜ ë¬¸ìì—´ì´ Anagramì¸ì§€ë¥¼ í™•ì¸í•˜ëŠ” ë¬¸ì œì…ë‹ˆë‹¤.
+ ì—¬ê¸°ì„œ Anagramì´ë€ ë¬¸ìì—´ ë‚´ì˜ ë¬¸ìë¥¼ ë‹¤ë¥´ê²Œ ë°°ì¹˜í•´ì„œ ìƒˆë¡œìš´ ë¬¸ìì—´ì„ ë§Œë“œëŠ” ê²ƒìœ¼ë¡œ ì£¼ì–´ì§„ ë¬¸ìì—´ì„ ëª¨ë‘ ì‚¬ìš©í•´ì•¼ í•©ë‹ˆë‹¤.

#### 2. ë‚˜ì˜ í’€ì´
##### ì‹œë„ 1
HashMapì„ ì´ìš©í•œ í’€ì´ì…ë‹ˆë‹¤. 
+ ```"hhbywxfzydbppjxnbhezsxepfexkzofxyqdvcgdvgnjbvih...```ì™€ ê°™ì´ ê¸´ í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ 41ë²ˆì—ì„œ ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.
  + s_mapê³¼ t_mapì€ ë™ì¼í•˜ê²Œ ìš”ì†Œê°€ ë“¤ì–´ê°„ ê²ƒì„ í™•ì¸í–ˆìœ¼ë‚˜ ì¼ë¶€ í…ŒìŠ¤íŠ¸ì¼€ì´ìŠ¤ return ê°’ì´ í‹€ë ¸ìŠµë‹ˆë‹¤.
  + ```if(s.length()!=t.length()) return false;``` ì—¬ê¸° ë¶€ë¶„ì´ ```false```ë¥¼ ë°˜í™˜í•˜ë©´ì„œ ìƒê¸´ ë¬¸ì œì˜€ìŠµë‹ˆë‹¤.

ì‹œê°„ë³µì¡ë„ì™€ ê³µê°„ë³µì¡ë„
+ ì‹œê°„ë³µì¡ë„: O(n)
+ ê³µê°„ë³µì¡ë„: O(n)

```java
class Solution {
  public boolean isAnagram(String s, String t) {
    Map<Character, Integer> s_map = makeMap(s);
    Map<Character, Integer> t_map = makeMap(t);
    
    if(s.length()!=t.length()) return false;

    for(int i=0; i<t.length(); i++){
      char c = t.charAt(i);
      if(!s_map.containsKey(c)) return false;
      if(s_map.get(c)!=t_map.get(c)) return false;
    }
    return true;
  }

  public Map<Character, Integer> makeMap(String str){
    Map<Character, Integer> map = new HashMap<>();
    for(int i=0; i<str.length(); i++){
      char c = str.charAt(i);
      if(map.containsKey(c)) map.put(c, map.get(c)+1);
      else map.put(c, 1);
    }
    return map;
  }
}
```

```java
// s_map
{a=1913, b=2003, c=2000, d=1916, e=1978, f=1880, g=1949, h=1943, i=1949, j=1891, k=1923, 
        l=1922, m=1936, n=1978, o=1869, p=1874, q=1875, r=1985, s=1897, t=1838, u=1879, 
        v=1905, w=1940, x=1942, y=1915, z=1900}
// t_map        
{a=1913, b=2003, c=2000, d=1916, e=1978, f=1880, g=1949, h=1943, i=1949, j=1891, k=1923, 
        l=1922, m=1936, n=1978, o=1869, p=1874, q=1875, r=1985, s=1897, t=1838, u=1879, 
        v=1905, w=1940, x=1942, y=1915, z=1900}
        
50000
50000
// if(s.length()!=t.length()) return false;        
false
```

#### 3. ë‹¤ë¥¸ ì‚¬ëŒì˜ í’€ì´
```Arrays.sort```ë¥¼ ì´ìš©í•´ì„œ ê°„ë‹¨í•˜ê²Œ í’€ì´í•œ ì½”ë“œì…ë‹ˆë‹¤. HashTableë¡œì˜ êµ¬í˜„ë§Œ ìƒê°í•˜ê³  ìˆì–´ì„œ ì˜¤íˆë ¤ ë– ì˜¬ë¦¬ì§€ ëª»í–ˆëŠ”ë° ì´ê²Œ ë” ë¹ ë¥¸ ì ‘ê·¼ë²•ì´ ë  ê²ƒ ê°™ìŠµë‹ˆë‹¤.
+ ì‹œê°„ë³µì¡ë„: O(n)
+ ê³µê°„ë³µì¡ë„: O(n)

```java
class Solution {
    public boolean isAnagram(String s, String t) {
        char[] sChars = s.toCharArray();
        char[] tChars = t.toCharArray();
        Arrays.sort(sChars);
        Arrays.sort(tChars);
        return Arrays.equals(sChars, tChars);
    }
}
```

Hash Tableì„ ì´ìš©í•œ ë°©ì‹ë„ ìˆì—ˆìŠµë‹ˆë‹¤. ```.getOrDefault()``` ë©”ì„œë“œë¡œ ë” ê°„ê²°í•˜ê²Œ ì½”ë“œë¥¼ êµ¬í˜„í–ˆê³  ë¬¸ìì—´ ```s```ì˜ ìš”ì†Œë¡œ mapì— ì¶”ê°€, ```t```ì˜ ìš”ì†Œë¡œ mapì—ì„œ ì°¨ê°í•˜ëŠ” ë°©ì‹ì…ë‹ˆë‹¤.
ê·¸ë¦¬ê³  ë§ˆì§€ë§‰ì—ëŠ” valueì˜ ê°’ì´ 0ì´ ì•„ë‹Œ ê²½ìš°ëŠ” ë‹¤ anagramì„ ë§Œì¡±í•˜ì§€ ëª»í•˜ë¯€ë¡œ ```false```ë¥¼ ë¦¬í„´í•©ë‹ˆë‹¤.
+ ì‹œê°„ë³µì¡ë„: O(n)
+ ê³µê°„ë³µì¡ë„: O(n)

```java
class Solution {
    public boolean isAnagram(String s, String t) {
        Map<Character, Integer> count = new HashMap<>();
        
        for (char x : s.toCharArray()) {
            count.put(x, count.getOrDefault(x, 0) + 1);
        }
        
        for (char x : t.toCharArray()) {
            count.put(x, count.getOrDefault(x, 0) - 1);
        }
        
        for (int val : count.values()) {
            if (val != 0) {
                return false;
            }
        }
        
        return true;
    }
}
```

#### 4. ìƒê°í•´ë³´ê¸°
```.getOrDefault(x, 0)```ë¥¼ ì´ìš©í•œ í’€ì´ë¥¼ ê·¸ ë™ì•ˆ ì½”ë”©í…ŒìŠ¤íŠ¸ ê³µë¶€ë¥¼ ì•ˆí•˜ê³  ìˆì–´ì„œ ê¸°ì–µí•˜ì§€ ëª»í–ˆëŠ”ë° ìë£Œêµ¬ì¡°ë³„ë¡œ í•„ìš”í•œ ë©”ì„œë“œë¥¼ ì •ë¦¬í•  í•„ìš”ì„±ì„ ëŠê¼ˆìŠµë‹ˆë‹¤.

---
<br>

### 383. Ransom Note
#### 1. ë¬¸ì œ
[ë¬¸ì œ URL](https://leetcode.com/problems/ransom-note/?envType=study-plan-v2&envId=top-interview-150)
+ ë‘ ê°œì˜ ë¬¸ìì—´ ```ransomNote```ì™€ ```magazine```ê°€ ì£¼ì–´ì¡Œì„ ë•Œ, ```ransomNote```ë¡œ ```magazine```ì„ ë§Œë“¤ ìˆ˜ ìˆëŠ”ì§€ ì—¬ë¶€ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤. 
+ ë‘ ë¬¸ìì—´ì€ ëª¨ë‘ ì˜ì–´ ì†Œë¬¸ìë¡œ ê°„ì£¼í•©ë‹ˆë‹¤.

#### 2. ë‚˜ì˜ í’€ì´
Hash Tableì„ ì´ìš©í•œ ë°©ì‹ìœ¼ë¡œ ```ransomNote```ì™€ ```magazine```ì„ mapìœ¼ë¡œ ë§Œë“¤ê³  ```ransomNote```ë¥¼ ë§Œë“¤ ìˆ˜ ìˆëŠ”ì§€ ì²´í¬í–ˆìŠµë‹ˆë‹¤.
```java
class Solution {
    public boolean canConstruct(String ransomNote, String magazine) {
        Map<Character, Integer> ransomNote_map = makeMap(ransomNote);
        Map<Character, Integer> magazine_map = makeMap(magazine);

        for(int i=0; i<ransomNote.length(); i++){
            char c = ransomNote.charAt(i);
            if(!magazine_map.containsKey(c)) return false;
            if(ransomNote_map.getOrDefault(c,0)>magazine_map.getOrDefault(c,0)) return false;
        }
        return true;
    }

    public Map<Character, Integer> makeMap(String str){
        Map<Character, Integer> map = new HashMap<>();
        for(int i=0; i<str.length(); i++){
            char c = str.charAt(i);
            if(map.containsKey(c)) map.put(c, map.get(c)+1);
            else map.put(c, 1);
        }
        return map;
    }
}

```

#### 3. ë‹¤ë¥¸ ì‚¬ëŒì˜ í’€ì´
ì œê°€ í‘¼ ì ‘ê·¼ë²•ë³´ë‹¤ ë¹ ë¥´ê³  ê°„ë‹¨í•œ ë°©ë²•ìœ¼ë¡œ ```.toCharArray()```ë¥¼ ì´ìš©í•œ í’€ì´ì…ë‹ˆë‹¤.
+ ë¨¼ì €, ```magazine``` ë¬¸ìì—´ì—ì„œ ê° ë¬¸ìì˜ ì¶œí˜„ ë¹ˆë„ìˆ˜ë¥¼ ì €ì¥í•˜ê¸° ìœ„í•´ ```charCounts```ë¼ëŠ” ê¸¸ì´ 26ì˜ ì •ìˆ˜ ë°°ì—´ì„ ìƒì„±í•©ë‹ˆë‹¤. ì´ ë°°ì—´ì€ ì†Œë¬¸ì ì˜ì–´ ì•ŒíŒŒë²³ì„ ê°€ì •í•˜ê³  ìˆìŠµë‹ˆë‹¤.
+ ë‹¤ìŒìœ¼ë¡œ, ```magazine``` ë¬¸ìì—´ì„ ìˆœíšŒí•˜ë©´ì„œ ê° ë¬¸ìì˜ ì¶œí˜„ ë¹ˆë„ìˆ˜ë¥¼ ```charCounts```ì— ì €ì¥í•©ë‹ˆë‹¤.
+ ê·¸ í›„, ```ransomNote``` ë¬¸ìì—´ì„ ìˆœíšŒí•˜ë©´ì„œ ê° ë¬¸ìê°€ ```charCounts```ì— ìˆëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤. 
  + ë§Œì•½ ```charCounts```ì— í•´ë‹¹ ë¬¸ìê°€ ì—†ë‹¤ë©´, ```ransomNote```ë¥¼ ë§Œë“¤ ìˆ˜ ì—†ê¸° ë•Œë¬¸ì— falseë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤. 
  + ê·¸ë ‡ì§€ ì•Šìœ¼ë©´, ```charCounts```ì—ì„œ í•´ë‹¹ ë¬¸ìì˜ ì¶œí˜„ ë¹ˆë„ìˆ˜ë¥¼ í•˜ë‚˜ ì¤„ì…ë‹ˆë‹¤.
+ ë§Œì•½ ```ransomNote```ì˜ ëª¨ë“  ë¬¸ìë¥¼ ìˆœíšŒí–ˆë‹¤ë©´, ```ransomNote```ë¥¼ ë§Œë“¤ ìˆ˜ ìˆê¸° ë•Œë¬¸ì— trueë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.

```java
class Solution {
    public boolean canConstruct(String ransomNote, String magazine) {
        int[] charCounts = new int[26]; // Assuming lowercase English letters
        
        for (char c : magazine.toCharArray()) {
            charCounts[c - 'a']++;
        }

        for (char c : ransomNote.toCharArray()) {
            if ( !(charCounts[c - 'a'] > 0 ) ) {
                return false;
            } 
                charCounts[c - 'a']--;
        }
        
        return true;
    }
}
```

#### 4. ìƒê°í•´ë³´ê¸°
ê³¼ì œì—ì„œëŠ” Hash Tableë¡œ ë¶„ë¥˜ë˜ì–´ ìˆì—ˆì§€ë§Œ êµ¬í˜„ì´ ì‰¬ìš´ ë‹¤ë¥¸ ë°©ë²•ë“¤ë„ ê³ ë¯¼í•´ë´ì•¼í•  ê²ƒ ê°™ìŠµë‹ˆë‹¤.

---
<br>

### 219. Contains Duplicate 2
#### 1. ë¬¸ì œ
[ë¬¸ì œ URL](https://leetcode.com/problems/contains-duplicate-ii/?envType=study-plan-v2&envId=top-interview-150)
+ ë°°ì—´ ```nums```ì™€ ì •ìˆ˜ ```k```ê°€ ì£¼ì–´ì¡Œì„ ë•Œ ê±°ë¦¬ ```k``` ë‚´ì— ë–¨ì–´ì ¸ ìˆëŠ” ë™ì¼í•œ ìš”ì†Œê°€ ìˆëŠ”ì§€ ì—¬ë¶€ë¥¼ í™•ì¸í•©ë‹ˆë‹¤.
+ ìˆìœ¼ë©´ ```true```, ì—†ìœ¼ë©´ ```false```

#### 2. ë‚˜ì˜ í’€ì´
##### ì‹œë„ 1
HashMapì„ ì´ìš©í•œ í’€ì´ì…ë‹ˆë‹¤. ë°°ì—´ì—ì„œ ë™ì¼í•œ ê°’ì´ ë‚˜ì˜¤ë©´ ìš”ì†ŒëŠ” í‚¤ë¡œ ê·¸ ì¸ë±ìŠ¤ëŠ” ê°’ì„ listë¡œ ë°›ì•„ì„œ ë„£ì–´ì¤ë‹ˆë‹¤.
```java
class Solution {
  public boolean containsNearbyDuplicate(int[] nums, int k) {
    Map<Integer, Integer> map = new HashMap<>();
    for(int i=0; i<nums.length; i++){
      if(map.containsKey(nums[i])){
        int a = map.get(nums[i]);
        if(i-a<=k) return true;
      }
      map.put(nums[i], i);
    }
    return false;
  }
}
```

#### 3. ë‹¤ë¥¸ ì‚¬ëŒì˜ í’€ì´
HashTable ë°©ì‹ì€ ë‹¤ë¥¸ ì‚¬ëŒë“¤ í’€ì´ì™€ ë¹„ìŠ·í–ˆìŠµë‹ˆë‹¤.  
ì•„ë˜ ì•Œê³ ë¦¬ì¦˜ì€ ìŠ¬ë¼ì´ë”© ìœˆë„ìš°(sliding window) ë°©ì‹ì„ ì‚¬ìš©í•©ë‹ˆë‹¤. ì‹¤ì œë¡œ HashTable ë°©ì‹ë³´ë‹¤ ë¹¨ëê³  ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ë„ ë‹¤ì†Œ ì‘ì•˜ìŠµë‹ˆë‹¤. 
+ ìœˆë„ìš°ì˜ ì•ìª½ì€ i ë²ˆì§¸ ìš”ì†Œì´ë©°, ë’¤ìª½ì€ k ê±°ë¦¬ë§Œí¼ ë–¨ì–´ì§„ ìš”ì†Œì…ë‹ˆë‹¤. ì´ ìœˆë„ìš° ë‚´ì— ìˆëŠ” ìš”ì†Œë“¤ì€ Setì„ ì‚¬ìš©í•˜ì—¬ ìœ ì§€ë©ë‹ˆë‹¤.
+ ìƒˆë¡œìš´ ìš”ì†Œë¥¼ Setì— ì¶”ê°€í•  ë•Œ, add() ë©”ì„œë“œê°€ falseë¥¼ ë°˜í™˜í•˜ë©´ ì´ë¯¸ Setì— í•´ë‹¹ ìš”ì†Œê°€ ì¡´ì¬í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤. ì´ ê²½ìš°, ì¤‘ë³µëœ ê°’ì´ ì¡´ì¬í•˜ë¯€ë¡œ trueë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.
+ for ë£¨í”„ì—ì„œ return trueê°€ ì‹¤í–‰ë˜ì§€ ì•Šê³  ë£¨í”„ê°€ ì¢…ë£Œë˜ë©´, ì¤‘ë³µëœ ê°’ì´ ì—†ë‹¤ëŠ” ê²ƒì„ ì˜ë¯¸í•©ë‹ˆë‹¤.

```java
public boolean containsNearbyDuplicate(int[] nums, int k) {
  Set<Integer> set = new HashSet<Integer>();
  for(int i = 0; i < nums.length; i++){
      if(i > k) set.remove(nums[i-k-1]);
      if(!set.add(nums[i])) return true;
  }
  return false;
}
```

#### 4. ìƒê°í•´ë³´ê¸°
ì¤‘ë³µëœ ê°’ì„ ì°¾ëŠ” ë¬¸ì œì™€ ê°™ì´ ìŠ¬ë¼ì´ë”© ìœˆë„ìš° ë°©ì‹ìœ¼ë¡œ í•´ê²°í•  ìˆ˜ ìˆëŠ” ë¬¸ì œê°€ ìˆë‹¤ë©´, HashTableë³´ë‹¤ ë” íš¨ìœ¨ì ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤. 
ìŠ¬ë¼ì´ë”© ìœˆë„ìš° ë°©ì‹ì´ ê³ ì •ëœ í¬ê¸°ì˜ ìœˆë„ìš°ë¥¼ ì‚¬ìš©í•˜ì—¬ ë°ì´í„°ë¥¼ ì²˜ë¦¬í•˜ê¸° ë•Œë¬¸ì—, ê³µê°„ ë³µì¡ë„ì™€ ì‹œê°„ ë³µì¡ë„ê°€ ë” íš¨ìœ¨ì ì¼ ìˆ˜ ìˆê¸° ë•Œë¬¸ì…ë‹ˆë‹¤.

---
<br>

### 1. Two Sum
#### 1. ë¬¸ì œ
[ë¬¸ì œ URL](https://leetcode.com/problems/two-sum/?envType=study-plan-v2&envId=top-interview-150)
+ ```nums``` ë°°ì—´ì—ì„œ ```target``` ê°’ì„ ë§Œë“¤ê¸° ìœ„í•œ ì¸ë±ìŠ¤ ìˆœì„œë¥¼ ë°°ì—´ë¡œ ë°˜í™˜í•˜ëŠ” ë¬¸ì œì…ë‹ˆë‹¤.
+ 167ë²ˆ ë¬¸ì œì™€ ë‹¬ë¦¬ ```nums```ê°€ ì •ë ¬ë˜ì§€ ì•Šì€ ìƒíƒœë¡œ ì£¼ì–´ì§‘ë‹ˆë‹¤.
+ ë°°ì—´ ë‚´ ìš”ì†ŒëŠ” í•œ ë²ˆë§Œ ì‚¬ìš©ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

#### 2. ë‚˜ì˜ í’€ì´
ê°€ì¥ ê°„ë‹¨í•˜ê²Œ forë¬¸ìœ¼ë¡œ í’€ì´í–ˆëŠ”ë°, ë¬¸ì œì—ì„œ ì›í•˜ëŠ” ì‹œê°„ë³µì¡ë„ O(n^2) ë¯¸ë§Œ ê·¸ë¦¬ê³  Hash Tableì„ ì´ìš©í•œ ë°©ë²•ì„ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.
+ ì‹œê°„ë³µì¡ë„: O(n^2)
+ ê³µê°„ë³µì¡ë„: O(n)

```java
class Solution {
  public int[] twoSum(int[] nums, int target) {
    List<Integer> list = new ArrayList<>();
    for(int i:nums){
      list.add(i);
    }
    int i=0, a=0, b=0;
    for(i=0; i<nums.length; i++){
      a = target-nums[i];
      b = list.lastIndexOf(a);
      if(a>0 && b!=-1 && b!=i){
        break;
      }
    }
    return new int[]{i, b};
  }
}
```

#### 3. ë‹¤ë¥¸ ì‚¬ëŒì˜ í’€ì´
Hash Tableì„ ì´ìš©í•œ í’€ì´ì…ë‹ˆë‹¤. ì²˜ìŒì—ëŠ” ì™œ êµ³ì´ Map ì²˜ë¦¬ë¥¼ í•˜ëŠ”ê°€ì— ëŒ€í•´ ìƒê°í–ˆì—ˆëŠ”ë° í‚¤-ê°’ ìŒ ì¡°íšŒì´ë¯€ë¡œ ì˜¤íˆë ¤ ë¹ ë¥¸ í’€ì´ê°€ ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤.  
+ ë¨¼ì € ```HashMap``` ì•ˆì— ```target```ê³¼ì˜ ì°¨ì´ë§Œí¼ì„ ê°€ì§€ëŠ” í‚¤ ê°’ì´ ìˆëŠ”ì§€ í™•ì¸í•˜ê³  ìˆë‹¤ë©´ ê·¸ ì¸ë±ìŠ¤ ë°°ì—´ì„ ë°˜í™˜í•©ë‹ˆë‹¤.
+ ì—†ë‹¤ë©´, ```i```ì˜ ê°’ì„ í‚¤ë¡œ í•˜ëŠ” ìš”ì†Œë¥¼ ì¶”ê°€í•©ë‹ˆë‹¤.

ì‹œê°„ë³µì¡ë„ì™€ ê³µê°„ë³µì¡ë„
+ ì‹œê°„ë³µì¡ë„: O(n)
+ ê³µê°„ë³µì¡ë„: O(n)

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> numMap = new HashMap<>();
        int n = nums.length;

        for (int i = 0; i < n; i++) {
            int complement = target - nums[i];
            if (numMap.containsKey(complement)) {
                return new int[]{numMap.get(complement), i};
            }
            numMap.put(nums[i], i);
        }

        return new int[]{}; // No solution found
    }
}
```

#### 4. ìƒê°í•´ë³´ê¸°
ëª¨ë“  í‚¤ë¥¼ ì°¾ì•„ì•¼ í•˜ëŠ” ë¬¸ì œê°€ ì•„ë‹ˆê³  í›„ë³´ í‚¤ë¥¼ ì–»ì„ ìˆ˜ ìˆëŠ” ë¬¸ì œì´ê¸° ë•Œë¬¸ì— ì˜¤íˆë ¤ HashMapì„ ì´ìš©í•˜ëŠ”ê²Œ ë¹ ë¥´ë‹¤ëŠ” ê²°ë¡ ì„ ì•Œ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

---
<br>

### 150. Evaluate Reverse Polish Notation
#### 1. ë¬¸ì œ
[ë¬¸ì œ URL](https://leetcode.com/problems/evaluate-reverse-polish-notation/?envType=study-plan-v2&envId=top-interview-150)
+ [Polish Notation](https://en.wikipedia.org/wiki/Reverse_Polish_notation) tokensì´ ì£¼ì–´ì§€ê³  ê²°ê³¼ê°’ì„ ë°˜í™˜í•©ë‹ˆë‹¤.
+ 0ìœ¼ë¡œ ë‚˜ëˆ„ëŠ” ì¼ì€ ì—†ê³ , ë‹µê³¼ ëª¨ë“  ì¤‘ê°„ ê³„ì‚°ì€ 32ë¹„íŠ¸ ì •ìˆ˜ë¡œ í‘œí˜„ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

#### 2. ë‚˜ì˜ í’€ì´
##### ì‹œë„ 1
ì™œ ì—­ í´ë€ë“œ í‘œê¸°ë²•ì„ ì‚¬ìš©í•˜ëŠ” ê²ƒì¸ì§€ ì°¾ë‹¤ê°€ [ìœ„í‚¤](https://ko.wikipedia.org/wiki/%EC%97%AD%ED%8F%B4%EB%9E%80%EB%93%9C_%ED%91%9C%EA%B8%B0%EB%B2%95) ê¸€ì„ í† ëŒ€ë¡œ 
ì½”ë“œë¥¼ ì‘ì„±í•˜ê²Œ ë˜ì—ˆìŠµë‹ˆë‹¤. stackì„ ì‚¬ìš©í•œ êµ¬í˜„ìœ¼ë¡œ ê´„í˜¸ê°€ ë§ì€ ê³„ì‚°ì‹ì—ì„œ ì˜¤íˆë ¤ ì—­ í´ë€ë“œ í‘œê¸°ë²•ì„ ì‚¬ìš©í•˜ë©´ ê³„ì‚°ì„ ì‰½ê²Œ ë§Œë“¤ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
+ ```EmptyStackException```ì´ ë°œìƒ
  + ```Character.isDigit```ë¥¼ ì‚¬ìš©í•˜ëŠ” ê²½ìš° ```-11```ì„ ìˆ«ìë¡œ ë³´ì§€ ì•ŠëŠ” ê²½ìš°ê°€ ë°œìƒí–ˆê¸° ë•Œë¬¸ì´ì—ˆìŠµë‹ˆë‹¤.

```java
class Solution {
  public int evalRPN(String[] tokens) {
    Stack<Integer> stack = new Stack<>();
    int next;
    for(String s:tokens){
      if(Character.isDigit(s.charAt(0))){
        stack.push(Integer.parseInt(s));
      }
      else{
        int b = stack.pop();
        int a = stack.pop();

        if("+".equals(s)) stack.push(a+b);
        else if("-".equals(s)) stack.push(a-b);
        else if("*".equals(s)) stack.push(a*b);
        else stack.push(a/b);
      }
      System.out.println(stack);
    }
    return stack.pop();
  }
}
```
##### ì‹œë„ 2
ë‹¤ë¥¸ ë¶€ë¶„ì€ ë¬¸ì œê°€ ì—†ëŠ”ë° ```EmptyStackException```ì´ ë°œìƒí•˜ì§€ ì•Šë„ë¡ ```Character.isDigit``` ëŒ€ì‹  ì‚¬ì¹™ì—°ì‚° ê¸°í˜¸ ì—¬ë¶€ë¥¼ ì²´í¬í•´ì„œ ì¡°ê±´ì„ ê±°ëŠ” ê²ƒìœ¼ë¡œ ë³€ê²½í–ˆìŠµë‹ˆë‹¤.
```java
if("+".equals(s) || "-".equals(s) || "*".equals(s) || "/".equals(s))
```

#### 3. ë‹¤ë¥¸ ì‚¬ëŒì˜ í’€ì´
ë‚˜ë¨¸ì§€ ì „ì²´ì ì¸ í’€ì´ëŠ” Stack ë°©ì‹ê³¼ ìœ ì‚¬í•˜ë‚˜ ë©”ì„œë“œë¥¼ ë¹¼ê±°ë‚˜ ì‚¬ì¹™ì—°ì‚°ì„ ë‹¤ìŒ ì½”ë“œì²˜ëŸ¼ setì— ë„£ì–´ì„œ í™•ì¸í•˜ëŠ” ë°©ë²• ë“±ì´ ìˆì—ˆìŠµë‹ˆë‹¤. ì½”ë“œê°€ ê¸¸ì–´ì§„ë‹¤ë©´ ê°€ë…ì„±ì„ ìœ„í•´ ê³„ì‚°ë¶€ë¶„ì„ ë©”ì„œë“œë¡œ ë¹¼ëŠ” ê²ƒë„ ì¢‹ì€ ë°©ë²•ì´ë¼ëŠ” ìƒê°ì´ ë“¤ì—ˆìŠµë‹ˆë‹¤.  
```Deque```ë¥¼ ì´ìš©í•œ í’€ì´ë„ ìˆì—ˆëŠ”ë° ê¸°ë³¸ì ìœ¼ë¡œ Stack êµ¬ì¡°ë§Œì„ ìƒê°í–ˆëŠ”ë° ì•Œê³ ë¦¬ì¦˜ ê³µë¶€ë¥¼ í•˜ë‹¤ê°€ ë³´ë©´ ```Deque```ë¥¼ ì‚¬ìš©í•œ í’€ì´ë„ ê½¤ ë§ì€ ê²ƒ ê°™ì•„ ì°¸ê³ í•˜ë©´ ì¢‹ì„ ê²ƒ ê°™ìŠµë‹ˆë‹¤.
```java
class Solution {
  public int evalRPN(String[] tokens) {
    Stack<Integer> stack = new Stack<>();
    Set<String> ops = Set.of("+", "-", "*", "/");

    for (String s : tokens) {
      if (ops.contains(s)) {
        int a = stack.pop();
        int b = stack.pop();
        int c = 0;

        switch(s) {
          case "+" -> {c = b + a;}
          case "-" -> {c = b - a;}
          case "*" -> {c = b * a;}
          case "/" -> {c = b / a;}
        }
        stack.push(c);
      }
      else stack.push(Integer.parseInt(s));
    }
    return stack.peek();
  }
}

// TC: O(n), SC: O(n)
```

#### 4. ìƒê°í•´ë³´ê¸°
```Deque```ëŠ” ìŠ¤íƒê³¼ íì˜ í˜•íƒœ ëª¨ë‘ êµ¬í˜„ì´ ê°€ëŠ¥í•œ ìë£Œêµ¬ì¡°ì…ë‹ˆë‹¤. ì–‘ìª½ ëì—ì„œ ì›ì†Œì˜ ì‚½ì…ê³¼ ì‚­ì œê°€ ê°€ëŠ¥í•©ë‹ˆë‹¤. ê·¸ë¦¬ê³  ArrayDequeëŠ” ë™ì ìœ¼ë¡œ í¬ê¸°ë¥¼ ì¡°ì ˆí•˜ëŠ” ë°°ì—´ ê¸°ë°˜ì˜ Deque êµ¬í˜„ì²´ì´ë©°, LinkedListëŠ” ì—°ê²° ë¦¬ìŠ¤íŠ¸ ê¸°ë°˜ì˜ Deque êµ¬í˜„ì²´ì…ë‹ˆë‹¤.
+ ê·¸ë ‡ë‹¤ë©´ ìŠ¤íƒ ë˜ëŠ” íë³´ë‹¤ ```Deque```ë¥¼ ì¼ì„ ë•Œ ë” ì í•©í•œ ë¬¸ì œê°€ ìˆì„ê¹Œ?ë¼ëŠ” ì§ˆë¬¸ì— ChatGPTëŠ” ë‹µì„ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.

---
<br>

### 155. Min Stack
#### 1. ë¬¸ì œ
[ë¬¸ì œ URL](https://leetcode.com/problems/min-stack/?envType=study-plan-v2&envId=top-interview-150)
+ ìŠ¤íƒì„ êµ¬í˜„í•˜ëŠ” ë¬¸ì œë¡œ push, pop, top ê·¸ë¦¬ê³  ê°€ì¥ ì‘ì€ ì›ì†Œë¥¼ ë™ì‹œì— ê²€ìƒ‰í•  ìˆ˜ ìˆì–´ì•¼ í•©ë‹ˆë‹¤.

```
Input
["MinStack","push","push","push","getMin","pop","top","getMin"]
[[],[-2],[0],[-3],[],[],[],[]]

Output
[null,null,null,null,-3,null,0,-2]

Explanation
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin(); // return -3
minStack.pop();
minStack.top();    // return 0
minStack.getMin(); // return -2
```

#### 2. ë‚˜ì˜ í’€ì´
##### ì‹œë„ 1
ê¸°ì¡´ì— êµ¬í˜„ì— ëŒ€í•œ ë¶€ë¶„ì„ ê³ ë¯¼í•´ë´¤ì„ ë•Œ LinkedListëŠ” ì£¼ì†Œë¡œ ë‹¤ìŒ ë¦¬ìŠ¤íŠ¸ì™€ ì—°ê²°ë˜ì–´ ìˆëŠ” ë°˜ë©´, ArrayListëŠ” ì„ í˜• êµ¬ì¡°ë¡œ ë˜ì–´ ìˆê¸° ë•Œë¬¸ì— O(n)ë§Œí¼ì˜ ì‹œê°„ë³µì¡ë„ê°€ ìƒê¹ë‹ˆë‹¤.
ë©”ëª¨ë¦¬ê°€ ë¬´í•œí•˜ë‹¤ê³  ê°€ì •í–ˆì„ ë•Œ LinkedListì˜ ê²½ìš° ë” ë¬´í•œíˆ ìƒˆë¡œìš´ ìë£Œë¥¼ ì‚½ì…í•  ìˆ˜ ìˆë‹¤ëŠ” ì¥ì ì´ ìˆìŠµë‹ˆë‹¤. ArrayListëŠ” ìë£Œì˜ ì‚½ì…, ì‚­ì œ ê³¼ì •ì—ì„œ ë©”ëª¨ë¦¬ ë‚­ë¹„ê°€ ë°œìƒí•©ë‹ˆë‹¤.  
ë¬¼ë¡  ì—¬ê¸°ì„œëŠ” ë‹¨ìˆœ stackì˜ êµ¬í˜„ì´ì§€ë§Œ, ì´ stackì„ ëˆ„êµ°ê°€ ì“´ë‹¤ëŠ” ê°€ì •í•˜ì— LinkedListë¡œ stackì„ êµ¬í˜„í–ˆìŠµë‹ˆë‹¤.
```java
class MinStack {
  LinkedList<Integer> list;

  public MinStack() {
    list = new LinkedList<>();
  }

  public void push(int val) {
    list.push(val);
  }

  public void pop() {
    list.removeFirst();
  }

  public int top() {
    return list.peekFirst();
  }

  public int getMin() {
    LinkedList<Integer> sortedList =  new LinkedList<>(list);
    Collections.sort(sortedList);
    return sortedList.peekFirst();
  }
}
```

#### 3. ë‹¤ë¥¸ ì‚¬ëŒì˜ í’€ì´
```TplusMin```ë¼ëŠ” í´ë˜ìŠ¤ë¥¼ ë‘ì–´ ```min``` ê°’ë„ ì €ì¥í•˜ë©´ì„œ ë§ˆì§€ë§‰ì— ```getMin()```ì²˜ë¦¬ì‹œ ë³„ë„ ì •ë ¬ì´ í•„ìš”í•˜ì§€ ì•Šë‹¤ëŠ” ì ì´ í›¨ì”¬ íš¨ìœ¨ì ì´ë¼ëŠ” ìƒê°ì´ ë“¤ì—ˆìŠµë‹ˆë‹¤. 
ì´ë ‡ê²Œ ë˜ë©´ ë‹¨ìˆœíˆ push ì²˜ë¦¬ì—ì„œë§Œ ì‹ ê²½ì„ ì¨ë„ ë˜ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤.
```java
class MinStack {
    LinkedList<TplusMin> stack;
    private class TplusMin {
        int val;
        int min;
        public TplusMin(int val, int min) {
            this.val = val;
            this.min = min;
        }
    }

    public MinStack() {
        stack = new LinkedList<>();
    }
    
    public void push(int val) {
        int newMin;
        if (stack.size() == 0){
            newMin = val;
        }
        else {
            int currentMin = stack.getFirst().min;
            newMin = val < currentMin ? val : currentMin;
        }
        stack.addFirst(new TplusMin(val, newMin));
    }
    
    public void pop() {
        stack.removeFirst();
    }
    
    public int top() {
        return stack.peekFirst().val;
    }
    
    public int getMin() {
        return stack.peekFirst().min;
    }
}
```

#### 4. ìƒê°í•´ë³´ê¸°
ë‹¨ìˆœíˆ stackì„ êµ¬í˜„í•œë‹¤ê³  í–ˆì„ ë•Œ listì— ì €ì¥ë  ê°’ì„ 1ê°€ì§€ íƒ€ì…ì´ ì•„ë‹Œ í´ë˜ìŠ¤ë¡œ ì •ì˜í•´ì„œ ì›í•˜ëŠ” ìë£Œêµ¬ì¡°ë¡œ ë§Œë“¤ì–´ ì²˜ë¦¬í•˜ëŠ” ë°©ë²•ì„ ìµí˜”ê³  
ê¼­ ìë£Œêµ¬ì¡° ì•„ë‹ˆì—¬ë„ ë‹¤ë¥¸ ì½”ë“œë¥¼ ì‘ì„±í•  ë•Œë„ ê°„ë‹¨í•œ class ë‹¨ìœ„ ê°ì²´ë¡œ ì €ì¥í•˜ëŠ” ë°©ì‹ì— ëŒ€í•´ ê³ ë¯¼í•´ë³´ê²Œ ë˜ì—ˆìŠµë‹ˆë‹¤.

---
<br>

### 3. Longest Substring Without Repeating Characters
#### 1. ë¬¸ì œ
[ë¬¸ì œ URL](https://leetcode.com/problems/longest-substring-without-repeating-characters/?envType=study-plan-v2&envId=top-interview-150)
+ ë°˜ë³µì„ í¬í•¨í•˜ì§€ ì•ŠëŠ” ë¬¸ìì—´ë¡œ ì˜ëì„ ë•Œ ìµœëŒ€ ê¸¸ì´ë¥¼ êµ¬í•˜ëŠ” ë¬¸ì œì…ë‹ˆë‹¤.

#### 2. ë‚˜ì˜ í’€ì´
##### ì‹œë„ 1
ë§ê·¸ëŒ€ë¡œ substringí•˜ëŠ” ë°©ì‹ìœ¼ë¡œ ì ‘ê·¼í–ˆì—ˆëŠ”ë° index ë²”ìœ„ë¥¼ ë„˜ì–´ì„œ ì´ ì ‘ê·¼ì´ ì•„ë‹Œ ë‹¤ë¥¸ ë°©ì‹ìœ¼ë¡œ ì‹œë„í•´ì•¼ê² ë‹¤ê³  ìƒê°í–ˆìŠµë‹ˆë‹¤.
```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        int answer = 1;
        for(int i=0; i<s.length()-1; i++){
            int j=i+1;
            while(j<s.length()){
                j++;
                String substring = s.substring(i,j);
                if(substring.indexOf(""+s.charAt(j))==-1){
                    answer = Math.max(answer, j-i);
                }
                else break;                
            }
        }
        return answer;
    }
}
```

#### ì‹œë„ 2
[209ë²ˆ ë¬¸ì œ](/job/2023/08/25/Coding_test.html#209-minimum-size-subarray-sum)ì—ì„œ ë°°ìš´ ìŠ¬ë¼ì´ë”© ìœˆë„ìš° ê°œë…ìœ¼ë¡œ ìƒê°í•´ë´¤ìŠµë‹ˆë‹¤.  
ìŠ¬ë¼ì´ë”© ìœˆë„ìš°ëŠ” ì—°ì†ëœ ë°ì´í„° êµ¬ì¡°ì—ì„œ ê³ ì • í¬ê¸°ì˜ ìœˆë„ìš°ë¥¼ ì›€ì§ì´ë©´ì„œ íŠ¹ì • ì¡°ê±´ì„ ë§Œì¡±í•˜ëŠ” ë¶€ë¶„ êµ¬ê°„ì„ íƒìƒ‰í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜ ê¸°ë²•ì…ë‹ˆë‹¤.
+ ì½”ë“œ ë‚´ì—ì„œ ```i```ì™€ ```j``` ë‘ ê°œì˜ ì¸ë±ìŠ¤ë¥¼ ì‚¬ìš©í•˜ì—¬ ìŠ¬ë¼ì´ë”© ìœˆë„ìš°ë¥¼ í˜•ì„±í•˜ê³ , ```seen``` ë°°ì—´ì„ ì‚¬ìš©í•˜ì—¬ ê° ë¬¸ìì˜ ì¤‘ë³µ ì—¬ë¶€ë¥¼ í™•ì¸í•˜ê³  ìˆìŠµë‹ˆë‹¤. 
+ ```i```ëŠ” ìŠ¬ë¼ì´ë”© ìœˆë„ìš°ì˜ ì™¼ìª½ ëì„, ```j```ëŠ” ìŠ¬ë¼ì´ë”© ìœˆë„ìš°ì˜ ì˜¤ë¥¸ìª½ ëì„ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤. 
+ ì´ ë•Œ ```j```ëŠ” ë°˜ë³µë¬¸ì„ í†µí•´ ìŠ¬ë¼ì´ë”© ìœˆë„ìš°ì˜ ì˜¤ë¥¸ìª½ìœ¼ë¡œ ì´ë™í•˜ë©° ì¡°ê±´ì„ ê²€ì‚¬í•©ë‹ˆë‹¤. 
+ ì—¬ê¸°ì„œ ```128```ì€ ì•„ìŠ¤í‚¤ ì½”ë“œ ê¸°ì¤€ì…ë‹ˆë‹¤.

ì‹œê°„ë³µì¡ë„ì™€ ê³µê°„ë³µì¡ë„
+ ì‹œê°„ë³µì¡ë„: O(n^2)
+ ê³µê°„ë³µì¡ë„: O(1)
```java
class Solution {
  public int lengthOfLongestSubstring(String s) {
    int answer = 0;
    for (int i=0; i<s.length(); i++) {
      boolean[] seen = new boolean[128];  
      int j=i;
      while (j<s.length() && !seen[s.charAt(j)]) {
        seen[s.charAt(j)] = true;
        j++;
      }
      answer = Math.max(answer, j-i); 
    }
    return answer;
  }
}
```

#### 3. ë‹¤ë¥¸ ì‚¬ëŒì˜ í’€ì´
ìœ„ì˜ í’€ì´ì™€ ë¹„ìŠ·í•œë° ì´ ê²½ìš°ëŠ” ```int[]``` ë°°ì—´ì„ ì´ìš©í•´ ë¹„êµì—¬ë¶€ë¥¼ ì²´í¬í•˜ê³  ìˆìŠµë‹ˆë‹¤. 
```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        int n = s.length();
        int maxLength = 0;
        int[] charIndex = new int[128];
        Arrays.fill(charIndex, -1);
        int left = 0;
        
        for (int right = 0; right < n; right++) {
            if (charIndex[s.charAt(right)] >= left) {
                left = charIndex[s.charAt(right)] + 1;
            }
            charIndex[s.charAt(right)] = right;
            maxLength = Math.max(maxLength, right - left + 1);
        }
        
        return maxLength;
    }
}
```

#### 4. ìƒê°í•´ë³´ê¸°
ì‹¤ìƒ ë‹¨ì–´ê°€ ë§ëŠ”ì§€ ë‹¤ í™•ì¸í•´ì•¼í•  ê²ƒ ê°™ì§€ë§Œ ê·¸ëŸ´ í•„ìš”ê°€ ì—†ë‹¤ëŠ” ê²ƒì„ ì•Œê²Œ ë˜ì—ˆìŠµë‹ˆë‹¤. ì–´ì°¨í”¼ ì¤‘ë³µì„ í”¼í•˜ê¸° ìœ„í•œ í•˜ë‚˜ì˜ ë¬¸ìë¡œ ì²´í¬í•œë‹¤ê³  í•´ë„ ê°™ì€ ê²°ê³¼ë¥¼ ê°€ì§€ê³  ì˜¬ ìˆ˜ ìˆê¸° ë•Œë¬¸ì…ë‹ˆë‹¤.
ìŠ¬ë¼ì´ë”© ìœˆë„ìš° ê°œë…ê³¼ ë°©ë²•ë“¤ì„ ìˆ™ì§€í•  í•„ìš”ê°€ ìˆìŠµë‹ˆë‹¤. í•˜ì§€ë§Œ ì´ ë°©ë²•ì€ 

---
<br>

### 209. Minimum Size Subarray Sum
#### 1. ë¬¸ì œ
[ë¬¸ì œ URL](https://leetcode.com/problems/minimum-size-subarray-sum/?envType=study-plan-v2&envId=top-interview-150)
+ ë°°ì—´ì˜ ìš”ì†Œë“¤ì˜ í•©ìœ¼ë¡œ ```target```ì´ ë˜ê¸° ìœ„í•œ ì„œë¸Œ ë°°ì—´ì˜ ìµœì†Œ ê¸¸ì´ë¥¼ êµ¬í•˜ëŠ” ë¬¸ì œì…ë‹ˆë‹¤.
+ ë°°ì—´ ```nums```ëŠ” ì •ë ¬ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.
+ ì„œë¸Œë°°ì—´ì´ ì—†ëŠ” ê²½ìš°ì—ëŠ” ```0```ì„ return í•©ë‹ˆë‹¤.
+ ì‹œê°„ë³µì¡ë„ê°€ O(n) ë˜ëŠ” O(n log n)ì¸ ë°©ë²•ì„ ì°¾ì•„ìŠµë‹ˆë‹¤.

#### 2. ë‚˜ì˜ í’€ì´
##### ì‹œë„ 1
ì´ì¤‘ë£¨í”„ ë°–ì— ìƒê°ë‚˜ì§€ ì•Šì•„ì„œ ì´ë ‡ê²Œ ì‹œë„í–ˆì§€ë§Œ ì—­ì‹œë‚˜ ì‹œê°„ì´ˆê³¼ë¡œ ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.
+ ì‹œê°„ë³µì¡ë„: O(n log n)
+ ê³µê°„ë³µì¡ë„: O(1)

```java
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        if(Arrays.binarySearch(nums, target)>=0) return 1;
        int j=1, cnt=0;
        boolean b = false;
        for(int i=0; i<nums.length; i++){
            int value = nums[i];
            j = i+1;
            while(true){
                if(j<=nums.length-1) value += nums[j];
                if(target==value){
                    b=true;
                    break;
                }
                if(j==nums.length-1 || target<value) break;
            }
            if(b) cnt = j-i+1;
        }
        return cnt;
    }
}
```

#### 3. ë‹¤ë¥¸ ì‚¬ëŒì˜ í’€ì´ë¥¼ ë³´ê³  ê°œì„ í•˜ê¸°
```ìŠ¬ë¼ì´ë”© ìœˆë„ìš°```ë¥¼ ì´ìš©í•œ í’€ì´ì—ˆëŠ”ë°, ì•ì—ì„œ ë‚˜ì˜ í’€ì´ì™€ ê°™ì´ forë¬¸ê³¼ whileë¬¸ì„ í•¨ê»˜ ì“°ëŠ” ë°©ì‹ì¸ë° íš¨ìœ¨ì ì´ë¼ëŠ” ë¶€ë¶„ì´ ë‹¬ëìŠµë‹ˆë‹¤.   

ë¨¼ì € ì„œë¸Œë°°ì—´ì´ ì—†ëŠ” ê²½ìš° ```0```ì„ ë°˜í™˜í•©ë‹ˆë‹¤. ê·¸ë¦¬ê³  ë¶€ë¶„ ë°°ì—´ì˜ í•©ì´ target ì´ìƒì´ ë˜ë„ë¡ left í¬ì¸í„°ë¥¼ ì´ë™ì‹œí‚¤ë©´ì„œ ìµœì†Œ ê¸¸ì´ë¥¼ ê°±ì‹ í•©ë‹ˆë‹¤.
+ ì‹œê°„ë³µì¡ë„: O(n)
+ ê³µê°„ë³µì¡ë„: O(1)

```java
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }

        int left = 0;
        int minLength = Integer.MAX_VALUE;
        int currentSum = 0;

        for (int right = 0; right < nums.length; right++) {
            currentSum += nums[right];

            while (currentSum >= target) {
                minLength = Math.min(minLength, right - left + 1);
                currentSum -= nums[left];
                left++;
            }
        }

        if (minLength != Integer.MAX_VALUE) 
            return minLength;
        else 
            return 0;
    }
}
```

#### 4. ìƒê°í•´ ë³¼ ë¶€ë¶„
ë‘ í¬ì¸í„°ë¥¼ ì´ìš©í•œ ë°©ë²•ê³¼ëŠ” ì•½ê°„ ìƒì´í–ˆëŠ”ë°, ìŠ¬ë¼ì´ë”© ìœˆë„ìš°ë¥¼ ì‚¬ìš©í•˜ëŠ” ë°©ë²•ì— ì¢€ ë” ëŠ¥ìˆ™í•´ì ¸ì•¼ ê² ë‹¤ê³  ìƒê°í–ˆìŠµë‹ˆë‹¤.

---
<br>

### 167. Two Sum 2 Input Array Is Sorted
#### 1. ë¬¸ì œ
[ë¬¸ì œ URL](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/?envType=study-plan-v2&envId=top-interview-150)
+ ì •ë ¬ëœ ë°°ì—´ ë‚´ ë‘ ìš”ì†Œë¥¼ ë”í•œ ê°’ìœ¼ë¡œ ì›í•˜ëŠ” ê°’ì„ ë§Œë“œëŠ” ë¬¸ì œì…ë‹ˆë‹¤.
+ ì´ ë•Œ ê·¸ ë°°ì—´ ë‚´ ë‘ ìš”ì†Œì˜ ìˆœì„œ ìŒì„ return í•©ë‹ˆë‹¤.

#### 2. ë‚˜ì˜ í’€ì´
##### ì‹œë„ 1
```Arrays.binarySearch```ë¡œ ì§ì´ ë˜ëŠ” indexë¥¼ êµ¬í•  ìˆ˜ ìˆì—ˆìŠµë‹ˆë‹¤.
+ ì´ë ‡ê²Œ í’€ì—ˆì„ ë•Œ ê¸°ë³¸ì ì¸ ì˜ˆì œëŠ” ë‹¤ í†µê³¼í–ˆì§€ë§Œ, ```[5,25,75]```ì—ì„œ ```100```ì´ ë  ìˆ˜ ìˆëŠ” ê°’ì„ ì°¾ëŠ” ê²ƒì—ì„œ ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.
+ outputì´ ```[1,-3]```ì´ ë‚˜ì™”ëŠ”ë° ```indexOf```ì™€ ì°©ê°í•˜ê³  ```-1```ë§Œì„ ë°˜í™˜í•œë‹¤ê³  ê°€ì •í–ˆê¸° ë•Œë¬¸ì…ë‹ˆë‹¤.
  + ```Arrays.binarySearch```ì€ ì°¾ì§€ ëª»í•œ ê²½ìš° ìŒìˆ˜ ê°’ì„ ë°˜í™˜í•©ë‹ˆë‹¤. ë°˜í™˜ ê°’ì€ keyì˜ ì •í™•í•œ ìœ„ì¹˜ê°€ ì•„ë‹ˆë¼ keyë¥¼ ì‚½ì…í•´ì•¼ í•  ìœ„ì¹˜ì— ëŒ€í•œ ìŒìˆ˜ ê°’ì„ ë°˜í™˜í•©ë‹ˆë‹¤.

```java
class Solution {
    public int[] twoSum(int[] numbers, int target) {
        int i=0, j=0;
        for(i=0; i<numbers.length; i++){
            j = Arrays.binarySearch(numbers, target-numbers[i]);
            if(j>0) break;
        }
        return new int[]{i+1, j+1};
    }
}
```
##### ì‹œë„ 2
ìœ„ì—ì„œ ```Arrays.binarySearch```ì˜ ìŒìˆ˜ ë¬¸ì œ, ë™ì¼í•œ ìˆ«ìê°€ ì—°ì†ìœ¼ë¡œ ìˆì„ ë•Œì˜ ê°™ì€ ì¸ë±ìŠ¤ ë°˜í™˜ë¬¸ì œ, ë°˜í™˜ ë°°ì—´ì˜ ì •ë ¬ë¬¸ì œ ë“±ì„ ê³ ë ¤í•´ì„œ ì½”ë“œë¥¼ ìˆ˜ì •í–ˆìŠµë‹ˆë‹¤.
+ ì‹œê°„ë³µì¡ë„: O(n log n)
+ ê³µê°„ë³µì¡ë„: O(1)

```java
class Solution {
    public int[] twoSum(int[] numbers, int target) {
        int i=0, j=0;
        for(i=0; i<numbers.length; i++){
            j = Arrays.binarySearch(numbers, target-numbers[i]);
            if(j>=0 && i!=j) break;
        }
        if(i<j) return new int[]{i+1, j+1};
        else return new int[]{j+1, i+1};
    }
}
```

#### 3. ë‹¤ë¥¸ ì‚¬ëŒì˜ í’€ì´ë¥¼ ë³´ê³  ê°œì„ í•˜ê¸°
ì£¼ì–´ì§„ ```nums``` ë°°ì—´ì´ ì •ë ¬ëœ ê°’ì´ë¯€ë¡œ ì–‘ìª½ì˜ ê°’ì„ ë”í•´ì„œ ```target```ë³´ë‹¤ ì‘ì€ì§€ í°ì§€ì— ë”°ë¼ í¬ì¸í„°ë¥¼ ë³€ê²½í•´ì£¼ëŠ” ë°©ì‹ì´ì—ˆìŠµë‹ˆë‹¤.
ì½”ë“œë„ í›¨ì”¬ ê¹”ë”í•˜ê³  ì´ ì ‘ê·¼ë²•ì„ ê¸°ì–µí•´ë‘ëŠ”ê²Œ ì¢‹ê² ë‹¤ëŠ” ìƒê°ì´ ë“¤ì—ˆìŠµë‹ˆë‹¤.
```java
class Solution {
  public int[] twoSum(int[] nums, int target) {
    int l = 0, r = nums.length - 1;
    while (nums[l] + nums[r] != target) {
      if (nums[l] + nums[r] < target)
        l++;
      else
        r--;
    }
    return new int[]{l + 1, r + 1};
  }
}
```

#### 4. ìƒê°í•´ ë³¼ ë¶€ë¶„
ì°¸ê³ í•œ í’€ì´ ì‘ì„±ìê°€ ì“´ ë‚´ìš©ì—ì„œ ì •ë ¬ëœ ë°°ì—´ì´ ì£¼ì–´ì¡Œì„ ë•Œ ê³ ë ¤í•´ë³¼ ë‚´ìš©ìœ¼ë¡œ ë‹¤ìŒ ë‚´ìš©ë“¤ì„ ì¶”ì²œí–ˆìŠµë‹ˆë‹¤. ì´ ë¬¸ì œì—ì„œëŠ” ë‘ í¬ì¸í„°ë¥¼ ì´ìš©í•œ ë°©ì‹ì„ ì‚¬ìš©í•œ ë°©ë²•ì´ì—ˆìŠµë‹ˆë‹¤.
+ ì´ì§„ ê²€ìƒ‰
+ ë‘ ê°œ(ë˜ëŠ” ì„¸ ê°œ)ì˜ í¬ì¸í„°
+ ìŠ¬ë¼ì´ë”© ìœˆë„ìš°
  + ìŠ¬ë¼ì´ë”© ìœˆë„ìš° ì•Œê³ ë¦¬ì¦˜ì˜ í•µì‹¬ ì•„ì´ë””ì–´ëŠ” ìœˆë„ìš°ì˜ ì‹œì‘ê³¼ ëì„ ì¡°ì ˆí•˜ë©´ì„œ í•„ìš”í•œ ì—°ì‚°ì„ ìˆ˜í–‰í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤. ì´ë¥¼ í†µí•´ ë¶ˆí•„ìš”í•œ ê³„ì‚°ì„ ì¤„ì´ê³ , ë¬¸ì œì˜ ë³µì¡ë„ë¥¼ ì¤„ì´ë©°, íš¨ìœ¨ì ìœ¼ë¡œ ë¬¸ì œë¥¼ í•´ê²°í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
+ ì˜¤ë¥¸ìª½ë¶€í„° ìˆœíšŒ

---
<br>

### 125. Valid Palindrome
#### 1. ë¬¸ì œ
[ë¬¸ì œ URL](https://leetcode.com/problems/valid-palindrome/?envType=study-plan-v2&envId=top-interview-150)
+ Palindromeì¸ì§€ë¥¼ ì°¾ëŠ” ë¬¸ì œì…ë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´ í† ë§ˆí† , ê¸°ëŸ¬ê¸°, ìš°ì˜ìš° ê°™ì€ ë¬¸ìì—´ ì—¬ë¶€ë¥¼ í™•ì¸í•©ë‹ˆë‹¤.
  + ```true``` or ```false```ë¡œ ë°˜í™˜
+ íŠ¹ìˆ˜ë¬¸ìì™€ ê³µë°±ì€ ì œì™¸í•˜ê³  ì˜ì ëŒ€ì†Œë¬¸ìëŠ” ë™ì¼í•˜ê²Œ ê°„ì£¼í•©ë‹ˆë‹¤.
+ ```" "``` ë¹ˆ ë¬¸ìì—´ë„ Palindromeìœ¼ë¡œ ê°„ì£¼í•©ë‹ˆë‹¤.

#### 2. ë‚˜ì˜ í’€ì´
##### ì‹œë„ 1
ë¬¸ìì—´ì„ char[] ë°°ì—´ë¡œ ë³€í™˜í•´ì„œ ë’¤ì˜ ë°°ì—´ì˜ ê°’ê³¼ ë¹„êµí•˜ëŠ” ë°©ì‹ìœ¼ë¡œ í’€ì´í–ˆìŠµë‹ˆë‹¤. 
+ ì´ ê²½ìš°, 458 / 485 í…ŒìŠ¤íŠ¸ì¼€ì´ìŠ¤ëŠ” í†µê³¼í–ˆì§€ë§Œ ```0P```ëŠ” í†µê³¼í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.
  + ë¬¸ì œì—ì„œ ```Alphanumeric characters include letters and numbers.```ë¡œ ìˆ«ìë„ ê³ ë ¤í•´ì•¼ í•˜ë¯€ë¡œ ìˆ˜ì •ì´ í•„ìš”í–ˆìŠµë‹ˆë‹¤.

```java
class Solution {
    public boolean isPalindrome(String s) {
        if(s.isEmpty()) return true;
        int end = s.length()-1;
        char[] arr = s.toCharArray();
        for(int i=0; i<arr.length/2; i++){
            if(!(arr[i] >= 'A' && arr[i] <= 'Z') && !(arr[i] >= 'a' && arr[i] <= 'z'))
                continue;
            while(true){
                if((arr[end] >= 'A' && arr[end] <= 'Z') || (arr[end] >= 'a' && arr[end] <= 'z'))
                    break;
                else end--;    
            }
            if(Character.toLowerCase(arr[i]) != Character.toLowerCase(arr[end]))            
                return false;
            else end--;
        }
        return true;
    }
}
```  
##### ì‹œë„ 2
ìœ„ ì½”ë“œì—ì„œ ìˆ«ìë¥¼ ë‹¤ì‹œ ë°˜ì˜í•œ ì½”ë“œë¡œ ì‘ì„±í–ˆì§€ë§Œ ì‹œê°„ì´ˆê³¼ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.
+ ```!(start >= 0 && start <= 9) && !(start >= 'a' && start <= 'z')```

```java
class Solution {
    public boolean isPalindrome(String s) {
        if(s.isEmpty()) return true;
        int end = s.length()-1;
        char[] arr = s.toCharArray();
        for(int i=0; i<arr.length/2; i++){
            int start = Character.toLowerCase(arr[i]);
            int compare = Character.toLowerCase(arr[end]);
            if(!(start >= 0 && start <= 9) && !(start >= 'a' && start <= 'z'))
                continue;
            while(true){
                if((compare >= 0 && compare <= 9) || (compare >= 'a' && compare <= 'z'))
                    break;
                else end--;    
            }
            if(start != compare) return false;
            else end--;
        }
        return true;
    }
}
```
##### ì‹œë„ 3
ì´ì¤‘ ë°˜ë³µë¬¸ ë•Œë¬¸ì— ë°œìƒí•œ ê²ƒ ê°™ì•„ì„œ ë‹¤ë¥¸ ë°©ë²•ì„ ìƒê°í•´ë³´ê²Œ ë˜ì—ˆìŠµë‹ˆë‹¤. whileë¬¸ìœ¼ë¡œ ì²˜ë¦¬í•˜ì§€ ì•Šê³  ë¯¸ë¦¬ ```s```ì˜ ìˆ«ìì™€ ì˜ë¬¸ì ì™¸ ë‹¤ë¥¸ ë¬¸ìëŠ” ê³µë°±ì²˜ë¦¬í•˜ëŠ” ë°©ë²•ì…ë‹ˆë‹¤. 
+ ì´ ê²½ìš°, 462 / 485 í…ŒìŠ¤íŠ¸ì¼€ì´ìŠ¤ëŠ” í†µê³¼í–ˆì§€ë§Œ ```0P```ëŠ” í†µê³¼í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.
  + ```if(!(arr[i] >= 0 && arr[i] <= 9) && !(arr[i] >= 'a' && arr[i] <= 'z')) arr[i]=' ';```
  + ì´ ë¶€ë¶„ì—ì„œ ```0```ì„ ê³µë°±ì²˜ë¦¬í•˜ê³  ìˆì—ˆëŠ”ë°, ```if(!(arr[i] >= '0' && arr[i] <= '9') && !(arr[i] >= 'a' && arr[i] <= 'z')) arr[i]=' ';
    }```ë¡œ ë³€ê²½í•´ì£¼ì—ˆìŠµë‹ˆë‹¤.

ê²°ê³¼ì ìœ¼ë¡œ í†µê³¼ëŠ” í–ˆì§€ë§Œ ë§ˆìŒì— ë“œëŠ” í’€ì´ëŠ” ì•„ë‹ˆì—ˆìŠµë‹ˆë‹¤.
+ ì‹œê°„ë³µì¡ë„: O(n)
+ ê³µê°„ë³µì¡ë„: O(n)

```java
class Solution {
    public boolean isPalindrome(String s) {
        if(s.isEmpty()) return true;
        s = s.toLowerCase();
        char[] arr = s.toCharArray();
        for(int i=0; i<arr.length; i++){
            if(!(arr[i] >= '0' && arr[i] <= '9') && !(arr[i] >= 'a' && arr[i] <= 'z')) arr[i]=' ';
        }
        String str = String.valueOf(arr).replaceAll(" ", "");
        arr = str.toCharArray();
        for(int i=0, j=arr.length-1; i<arr.length/2; i++, j--){
            if(arr[i]!=arr[j]) return false;
        }
        return true;
    }
}
```

#### 3. ë‹¤ë¥¸ ì‚¬ëŒì˜ í’€ì´ë¥¼ ë³´ê³  ê°œì„ í•˜ê¸°
```Character.isLetterOrDigit```ë¥¼ ì‚¬ìš©í•´ì„œ ì½”ë“œë¥¼ í™•ì‹¤íˆ ê¹”ë”í•˜ê²Œ ì²˜ë¦¬í•œ ê²ƒì„ ë³¼ ìˆ˜ ìˆì—ˆìŠµë‹ˆë‹¤. 
ê·¸ë¦¬ê³  ì €ëŠ” ë°°ì—´ë¡œ ë³€í™˜í–ˆë‹¤ê°€ ë¬¸ìì—´ë¡œ í•©ì¹˜ëŠ” ê³¼ì •ì„ ê±°ì³¤ëŠ”ë° ê·¸ëƒ¥ ë°˜ë³µë¬¸ì„ ëŒë©´ì„œ ë¬¸ìì—´ì˜ ë¬¸ì ìœ„ì¹˜ë¥¼ ```left```ì™€ ```right```ë¡œ ì²˜ë¦¬í•´ì„œ ë¹„êµí•˜ëŠ” ë²•ì„ ë°°ì› ìŠµë‹ˆë‹¤.
+ ì‹œê°„ë³µì¡ë„: O(n)
+ ê³µê°„ë³µì¡ë„: O(1)

```java
class Solution {
   public boolean isPalindrome(String s) {
        if (s.isEmpty()) {
            return true;
        }

        int left = 0;
        int right = s.length() - 1;

        while (left < right) {
            char leftChar = s.charAt(left);
            char rightChar = s.charAt(right);

            if (!Character.isLetterOrDigit(leftChar)) {
                left++;
            } else if (!Character.isLetterOrDigit(rightChar)) {
                right--;
            } else {
                if (Character.toLowerCase(leftChar) != Character.toLowerCase(rightChar)) {
                    return false;
                }
                left++;
                right--;
            }
        }

        return true;
    }
}
```

#### 4. ìƒê°í•´ ë³¼ ë¶€ë¶„
ë„ˆë¬´ ë³µì¡í•˜ê²Œ ìƒê°í•˜ì§€ ë§ê³ , ê¸°ì¡´ ë¬¸ìì—´ì„ ìµœëŒ€í•œ ë³€í™˜í•˜ì§€ ì•ŠëŠ” ì„ ì—ì„œ ë¬¸ì œë¥¼ í’€ì–´ì•¼ê² ë‹¤ëŠ” ìƒê°ì´ ë“¤ì—ˆìŠµë‹ˆë‹¤.

----
<br>

### 169. Majority Element
#### 1. ë¬¸ì œ
[ë¬¸ì œ URL](https://leetcode.com/problems/majority-element/?envType=study-plan-v2&envId=top-interview-150)
+ ë°°ì—´ì—ì„œ ìµœëŒ€ ë¹ˆë„ ê°’ì„ êµ¬í•˜ëŠ” ë¬¸ì œì…ë‹ˆë‹¤. 
+ ìµœë¹ˆê°’ì€ ì ì–´ë„ ```ë°°ì—´ì˜ ê¸¸ì´/2``` ì´ìƒì˜ ë¹ˆë„ë¥¼ ê°–ìŠµë‹ˆë‹¤.
+ ì¶”ê°€ë¡œ ì‹œê°„ë³µì¡ë„ O(n), ê³µê°„ë³µì¡ë„ O(1)ì˜ ë°©ë²•ìœ¼ë¡œ í’€ ìˆ˜ ìˆëŠ”ì§€ ì•Œì•„ë³´ëŠ” ë¬¸ì œì…ë‹ˆë‹¤.

#### 2. ë‚˜ì˜ í’€ì´
ë¨¼ì € ì œê°€ ìƒê°í•œ ë°©ì‹ì€ mapì— ê°™ì€ í‚¤ë¥¼ ê°€ì§€ëŠ” ê°’ì„ ë„£ì–´ì£¼ê³  ì¤‘ë³µëœ í‚¤ë¥¼ ê°–ëŠ” ê²½ìš° ì¤‘ë³µëœ ìˆ˜ë¥¼ ê°’ìœ¼ë¡œ ë„£ì–´ì£¼ëŠ” ë°©ì‹ì´ì—ˆìŠµë‹ˆë‹¤.
í†µê³¼ëŠ” í–ˆì§€ë§Œ ë¬¸ì œì—ì„œ ê³ ë ¤í•´ë´ì•¼í•  ë³µì¡ë„ ë¶€ë¶„ì—ì„œëŠ” ë¶€ì¡±í–ˆìŠµë‹ˆë‹¤.
+ ì‹œê°„ ë³µì¡ë„: O(n + n log n)
+ ê³µê°„ ë³µì¡ë„: O(n)

```java
class Solution {
  public int majorityElement(int[] nums) {
    int limit = nums.length/2;
    Map<Integer, Integer> map = new HashMap<>();
    for(int i:nums){
      if(map.containsKey(i) map.put(i, map.get(i)+1);
      else map.put(i, 1);
    }
    List<Integer> keySet = new ArrayList<>(map.keySet());
    keySet.sort((o1, o2) -> map.get(o2).compareTo(map.get(o1)));
    return keySet.get(0);
  }
}
```

#### 3. ë‹¤ë¥¸ ì‚¬ëŒì˜ í’€ì´ë¥¼ ë³´ê³  ê°œì„ í•˜ê¸°
**```Arrays.sort(nums)``` ì´ìš©í•˜ê¸°**  
ê°€ì¥ ë¨¼ì € ë³¸ í’€ì´ëŠ” ì´ ë°©ë²•ì´ì—ˆëŠ”ë° ì´ë ‡ê²Œ ëœë‹¤ê³  í•˜ëŠ” ìƒê°ì´ ë“¤ì—ˆì§€ë§Œ, ìƒê°í•´ë³´ë‹ˆ ```limit``` ë¶€ë¶„ì„ ë¬¸ì œ í’€ë©´ì„œ ìŠê³  ìˆì—ˆìŠµë‹ˆë‹¤.
ìµœëŒ€ ë¹ˆë„ ê°’ì€ ```ë°°ì—´ì˜ ê¸¸ì´/2``` ì´ìƒì˜ ë¹ˆë„ë¥¼ ê°–ê¸° ë•Œë¬¸ì— ì •ë ¬ë¡œ ì¤‘ì•™ê°’ë§Œ ë„ì¶œí•´ë„ ê°’ì€ ê°’ì´ ë‚˜ì˜¬ ìˆ˜ ìˆëŠ” ë¬¸ì œì˜€ìŠµë‹ˆë‹¤.
í•˜ì§€ë§Œ ì›í•˜ëŠ” ì‹œê°„, ê³µê°„ ë³µì¡ë„ëŠ” ì•„ë‹ˆì˜€ìŠµë‹ˆë‹¤.
+ ì‹œê°„ ë³µì¡ë„: O(n log n)
+ ê³µê°„ ë³µì¡ë„: O(1)

```java
class Solution {
    public int majorityElement(int[] nums) {
        Arrays.sort(nums);
        int n = nums.length;
        return nums[n/2];
    }
}
```

**Moore Voting Algorithm**  
ê³¼ë°˜ìˆ˜ ìš”ì†Œë¥¼ êµ¬í•˜ê¸° ìœ„í•œ Moore Voting Algorithmì…ë‹ˆë‹¤.
+ ë³€ìˆ˜ candidateë¥¼ ê³¼ë°˜ìˆ˜ ìš”ì†Œ í›„ë³´ë¡œ ì´ˆê¸°í™”í•˜ê³ , countë¥¼ 0ìœ¼ë¡œ ì´ˆê¸°í™”í•©ë‹ˆë‹¤.
  + ë°°ì—´ì„ ìˆœíšŒí•˜ë©´ì„œ ê° ìš”ì†Œì— ëŒ€í•´ ë‹¤ìŒì„ ìˆ˜í–‰í•©ë‹ˆë‹¤.
  + ë§Œì•½ countê°€ 0ì´ë¼ë©´ í˜„ì¬ ìš”ì†Œë¥¼ candidateë¡œ ì„¤ì •í•©ë‹ˆë‹¤.
  + ë§Œì•½ í˜„ì¬ ìš”ì†Œê°€ candidateì™€ ê°™ë‹¤ë©´ countë¥¼ ì¦ê°€ì‹œí‚µë‹ˆë‹¤.
  + ê·¸ë ‡ì§€ ì•Šìœ¼ë©´ countë¥¼ ê°ì†Œì‹œí‚µë‹ˆë‹¤.
  
+ ì‹œê°„ ë³µì¡ë„: O(n)
+ ê³µê°„ ë³µì¡ë„: O(1)

```java
class Solution {
    public int majorityElement(int[] nums) {
        int count = 0;
        int candidate = 0;
        
        for (int num : nums) {
            if (count == 0) {
                candidate = num;
            }
            if (num == candidate) {
                count++;
            } else {
                count--;
            }
        }
        return candidate;
    }
}
```

#### 4. ìƒê°í•´ ë³¼ ë¶€ë¶„
**Moore Voting Algorithm**ì´ ìƒì†Œí–ˆëŠ”ë° ì´ë²ˆ ê¸°íšŒì— ê³¼ë°˜ìˆ˜ ì´ìƒì˜ ìš”ì†Œë¥¼ êµ¬í•˜ê¸° ìœ„í•´ ì¢‹ì€ ì•Œê³ ë¦¬ì¦˜ì— ëŒ€í•´ ê³µë¶€í•˜ê²Œ ë˜ì—ˆìŠµë‹ˆë‹¤.  
ìœ„ì—ì„œ ê°€ì¥ ì´í•´ë˜ì§€ ì•Šì•˜ë˜ ë¶€ë¶„ì´ ```candidate = num;``` ë¶€ë¶„ì´ì—ˆëŠ”ë° ì²˜ìŒì— ê°’ì„ ë„£ëŠ” ê±´ ë‹¹ì—°í–ˆì§€ë§Œ ê°’ì„ ë„£ì€ ì´í›„ì— ë‹¤ë¥¸ ìš”ì†Œë¡œ ë¹ˆë„ë¡œ ê·¸ ê°’(count)ì„ ì¤„ì´ê³  0ì´ ë˜ë©´ ë‹¤ë¥¸ ìš”ì†Œë¥¼ í›„ë³´ìë¡œ ë„£ëŠ”ë‹¤ëŠ”ê²Œ ì²˜ìŒì— ì´í•´ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. 

í•˜ì§€ë§Œ ê°„ë‹¨í•˜ê²Œ ì˜ˆì œë¡œ ì£¼ì–´ì§„ ë°°ì—´ ```2,2,1,1,1,2,2```ì„ ë„£ì–´ì„œ ìƒê°í•´ë³´ë©´ ì˜¤íˆë ¤ ì‰¬ì› ëŠ”ë° ê²°êµ­ì—ëŠ” ì´ ì•Œê³ ë¦¬ì¦˜ì´ **ê³¼ë°˜ìˆ˜ ì´ìƒì˜ ìš”ì†Œê°€ ìˆë‹¤ëŠ” ì „ì œ**ê°€ ìˆì—ˆê¸° ë•Œë¬¸ì— ê°€ëŠ¥í•˜ë¯€ë¡œ ì´ ë¶€ë¶„ì„ ê³ ë ¤í•  í•„ìš”ê°€ ìˆìŠµë‹ˆë‹¤.

---
<br>

### 80. Remove Duplicates from Sorted Array 2
#### 1. ë¬¸ì œ
[ë¬¸ì œ URL](https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/?envType=study-plan-v2&envId=top-interview-150)
+ ì£¼ì–´ì§„ ë°°ì—´ì—ì„œ ìˆœì„œëŒ€ë¡œ ë™ì¼í•œ ìš”ì†Œê°€ 3ê°œ ì´ìƒ ì—°ì†ë˜ì§€ ì•Šë„ë¡ ë§Œë“¤ì–´ì•¼ í•˜ëŠ” ë¬¸ì œì…ë‹ˆë‹¤.
+ ```1,1,2,2,2,3```ì¼ ë•Œ, ```1,1,2,2,3,_```ìœ¼ë¡œ ë§Œë“¤ê³  ê·¸ ìš”ì†Œì˜ ìˆ˜ë¥¼ returní•©ë‹ˆë‹¤.

#### 2. ë‚˜ì˜ í’€ì´
ë¨¼ì € ì–´ë–»ê²Œ í’€ì§€ì— ëŒ€í•´ ê³ ë¯¼í–ˆëŠ”ë° 26ë²ˆ ë¬¸ì œë¥¼ í’€ ë•Œ ìµíŒ í¬ì¸í„° ë°©ì‹ìœ¼ë¡œ í’€ê³  ì‹¶ì—ˆëŠ”ë° ë‘ ë²ˆì§¸ ifë¬¸ì—ì„œ ë°©ë²•ì´ ìƒê°ë‚˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤..

```java
class Solution {
  public int removeDuplicates(int[] nums) {
    int a=1, cnt=0;
    for(int i=1; i<nums.length; i++){
      if(nums[i]==nums[i-1]) cnt++;
      if(cnt>=2 || nums[i]!=nums[i-1]){
        //cnt=0;
        nums[a++]=nums[i];
      }

    }
    return a;
  }
}
```

#### 3. ë‹¤ë¥¸ ì‚¬ëŒì˜ í’€ì´ë¥¼ ë³´ê³  ê°œì„ í•˜ê¸°
```java
class Solution {
    public int removeDuplicates(int[] nums) {
        if (nums.length <= 2) {
            return nums.length;
        }
        int index = 2;
        for (int i = 2; i < nums.length; i++) {
            if (nums[i] != nums[index - 2]) {
                nums[index] = nums[i];
                index++;
            }
        }
        return index;
    }
}
```
+ ë¨¼ì € ```nums```ê°€ 2ë³´ë‹¤ ì‘ë‹¤ë©´ ë‹¹ì—°íˆ ë³„ë„ì˜ ê³„ì‚°ì´ í•„ìš”í•˜ì§€ ì•Šìœ¼ë¯€ë¡œ ê·¸ ê¸¸ì´ë¥¼ return í•©ë‹ˆë‹¤.
+ ê·¸ë¦¬ê³  ì‹œì‘ë˜ëŠ” ```i```ì™€ ```index```ë„ 2ì˜ ê°’ë¶€í„° ì§„í–‰ë  ìˆ˜ ìˆë„ë¡ í•©ë‹ˆë‹¤.
+ ì‹œê°„ë³µì¡ë„: O(n)
+ ê³µê°„ë³µì¡ë„: O(1)

#### 4. ìƒê°í•´ ë³¼ ë¶€ë¶„
```java
if (nums[i] != nums[index - 2]) {
    nums[index] = nums[i];
    index++;
}
```
ì´ ë¶€ë¶„ì— ëŒ€í•œ ë‚´ìš©ì´ í—·ê°ˆë ¸ëŠ”ë° ì‹¤ì œë¡œ ```index```ë¡œ ë“¤ì–´ê°„ ë°°ì—´ë“¤ì€ ì°¨ê³¡ì°¨ê³¡ ì¤‘ë³µì„ 2ê°œê¹Œì§€ í—ˆìš©í•œ ê°’ë“¤ì´ê³ 
```nums[i]```ì˜ ê°’ì´ ê¸°ì¡´ì— ê°’ë“¤ê³¼ ë‹¤ë¥¸ ê²½ìš°(ìƒˆë¡œ ìŒ“ì€ ë°°ì—´ê³¼ ë‹¤ë¥¸ ê²½ìš°), ```nums[index] = nums[i];```ë¡œ ë‹¤ë¥¸ ìš”ì†Œë¥¼ ë„£ì–´ì¤ë‹ˆë‹¤.

---
<br>

### 26. Remove Duplicates from Sorted Array
#### 1. ë¬¸ì œ
[ë¬¸ì œ URL](https://leetcode.com/problems/remove-duplicates-from-sorted-array/?envType=study-plan-v2&envId=top-interview-150)
+ ì •ë ¬ëœ ë°°ì—´ ```nums```ì˜ ì¤‘ë³µê°’ì„ ì œì™¸í•œ ìš”ì†Œì˜ ìˆ˜ë¥¼ returní•˜ëŠ” ë¬¸ì œì…ë‹ˆë‹¤.
+ ë°°ì—´ì˜ ì¤‘ë³µê°’ì€ ì—†ì–´ì•¼ í•©ë‹ˆë‹¤.

#### 2. ë‚˜ì˜ í’€ì´
```java
class Solution {
    public int removeElement(int[] nums, int val) {
        nums = Arrays.stream(nums).distinct().toArray();
        return nums.length;
    }
}
```
IDEì—ì„œì™€ ë‹¬ë¦¬ ```nums``` ê°’ì˜ outputì´ ì¤‘ë³µê°’ì´ ì œê±°ë˜ì§€ ì•Šì€ ìƒíƒœë¡œ ë‚˜ì™€ì„œ ë‹¤ì‹œ ê³ ë¯¼í•˜ê²Œ ë˜ì—ˆìŠµë‹ˆë‹¤.
+ ì‹œê°„ë³µì¡ë„: O(n)
+ ê³µê°„ë³µì¡ë„: O(n)

#### 3. ë‹¤ë¥¸ ì‚¬ëŒì˜ í’€ì´ë¥¼ ë³´ê³  ê°œì„ í•˜ê¸°
```java
class Solution {
    public int removeDuplicates(int[] nums) {
        int a=1;
        for(int i=1; i<nums.length; i++){
            if(nums[i]!=nums[i-1]){
                nums[a++]=nums[i];
            }
        }
        return a;
    }
}
```
```nums```ì˜ ê°’ì´ ì•ì˜ ê°’ê³¼ ê°™ì§€ ì•Šìœ¼ë©´, ì¸ë±ìŠ¤ a ìœ„ì¹˜ì— ëŒ€ì…í•˜ê²Œ ë©ë‹ˆë‹¤.

#### 4. ìƒê°í•´ ë³¼ ë¶€ë¶„
streamì—ì„œ ì‚¬ìš©ë˜ëŠ” ```distinct()```ì™€ ```toArray()```ëŠ” ê°ì²´ë¥¼ ìƒˆë¡œ ìƒì„±, ë©”ëª¨ë¦¬ë¥¼ ì¶”ê°€ë¡œ í•„ìš”ë¡œ í•œë‹¤ëŠ” ì ì—ì„œ ê³µê°„ë³µì¡ë„ ê²°ê³¼ê°€ ì¢‹ì§€ ì•Šê²Œ ë‚˜ì™”ìŠµë‹ˆë‹¤.  
ìƒˆë¡œìš´ ê°ì²´ ìƒì„±ë³´ë‹¤ëŠ” ì£¼ì–´ì§„ ```nums``` ê°ì²´ ê°’ì— ë³€í™”ë¥¼ ì£¼ëŠ” ë°©ì‹ìœ¼ë¡œ í•´ê²°í•˜ëŠ” ê²ƒì„ ìƒê°í•´ë´ì•¼ í•©ë‹ˆë‹¤.

---
<br>

### 27. Remove Element
#### 1. ë¬¸ì œ
[ë¬¸ì œ URL](https://leetcode.com/problems/remove-element/?envType=study-plan-v2&envId=top-interview-150)
+ ```nums``` ë°°ì—´ê³¼ ë°°ì—´ì—ì„œ ì‚­ì œí•´ì•¼ í•˜ëŠ” ìš”ì†Œê°€ ì£¼ì–´ì§‘ë‹ˆë‹¤.
+ return ê°’ì€ ë°°ì—´ë¡œ ì‚­ì œí•œ ìš”ì†Œë¥¼ ì œì™¸í•œ ìš”ì†Œì˜ ìˆ˜ì…ë‹ˆë‹¤.

#### 2. ë‚˜ì˜ í’€ì´
```java
class Solution {
    public int removeElement(int[] nums, int val) {
        int answer = 0;
        for(int i=0; i<nums.length; i++){
            if(nums[i]!=val){ 
                nums[answer] = nums[i];
                answer++;
            }    
        }
        return answer;
    }
}
```
ì²˜ìŒì— return ê°’ë§Œ ê³ ë ¤í•´ì„œ forë¬¸ìœ¼ë¡œ ë§Œë“¤ì—ˆëŠ”ë° ```nums[answer] = nums[i];```ì™€ ê°™ì€ ë°©ì‹ìœ¼ë¡œ ```nums``` ë°°ì—´ë„ ë‹¤ì‹œ ê³ ë ¤í•´ì•¼ í•´ì„œ ì¶”ê°€í•´ì£¼ì—ˆìŠµë‹ˆë‹¤.
ì´ë ‡ê²Œ í•˜ë©´ ```val```ê³¼ ê°™ì§€ ì•Šì€ ê°’ë“¤ë§Œ ```nums``` ë°°ì—´ ì•ì— ë†“ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
+ ì‹œê°„ë³µì¡ë„: O(n)
+ ê³µê°„ë³µì¡ë„: O(1)

#### 3. ë‹¤ë¥¸ ì‚¬ëŒì˜ í’€ì´ë¥¼ ë³´ê³  ê°œì„ í•˜ê¸°
```java
class Solution {
    public int removeElement(int[] nums, int val) {
        int count=0; //variable for occurance
        int i=0; 
        int j=nums.length-1;
        while(i<nums.length){
            if(nums[i]==val){
               nums[i]=nums[j];
               nums[j]=-1;
               j--;
               count++;
            }
            else{
                i++;
            }
        }
        return nums.length-count;
    }
}
```
ì´ ë¬¸ì œë„ í¬ì¸í„°ë¡œ ì ‘ê·¼í•œ ë¶„ë„ ìˆì—ˆëŠ”ë° ì‹œê°„ë³µì¡ë„ì™€ ê³µê°„ë³µì¡ë„ê°€ ì´ ê²½ìš°ëŠ” ì €ì˜ í’€ì´ì™€ ê°™ì•˜ìŠµë‹ˆë‹¤.
```val``` ê°’ê³¼ ê°™ì€ ê²½ìš°ëŠ” ë‹¤ì‹œ ```nums``` ë’¤ì— ìš”ì†Œ ê°’ì„ ë„£ì–´ì£¼ëŠ” ë¶€ë¶„ì´ ìƒˆë¡œì› ìŠµë‹ˆë‹¤.

#### 4. ìƒê°í•´ ë³¼ ë¶€ë¶„
í¬ì¸í„°ë¥¼ ì´ìš©í•œ í’€ì´ê°€ ì •ë ¬ ë¬¸ì œì—ì„œ ì‹œê°„ë³µì¡ë„ë¥¼ ì¤„ì¼ ìˆ˜ ìˆëŠ” ë°©ë²•ì´ë¯€ë¡œ ì¢€ ë” ìµìˆ™í•´ì§€ë„ë¡ í•´ì•¼ê² ìŠµë‹ˆë‹¤.

---
<br>

### 88. Merge Sorted Array
#### 1. ë¬¸ì œ
[ë¬¸ì œ URL](https://leetcode.com/problems/merge-sorted-array/description/?envType=study-plan-v2&envId=top-interview-150)
+ ```nums1```ê³¼ ```nums2```ê°€ ì£¼ì–´ì§€ê³  ```nums1``` ì•ˆì— ë³‘í•©í•œ ë’¤ ì •ë ¬í•˜ëŠ” ë¬¸ì œì…ë‹ˆë‹¤.
+ ë³„ë„ì˜ return ê°’ì€ ì—†ìŠµë‹ˆë‹¤.

#### 2. ë‚˜ì˜ í’€ì´
```java
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        for(int i=0; i<n; i++){
            nums1[m+i] = nums2[i];
        }
        Arrays.sort(nums1);
    }
}
```
```nums1```ì˜ í¬ê¸°ê°€ ì›ë˜ ë¬¸ì œì—ì„œ n+mì˜ í¬ê¸°ë¡œ ì£¼ì–´ì§€ê¸° ë•Œë¬¸ì— mê°œ ì™¸ì˜ ê°’ì€ 0ìœ¼ë¡œ ë˜ì–´ ìˆë‹¤ê³  ìƒê°ì„ í•˜ê³  ê·¸ ì´í›„ì˜ ê°’ë§Œ ```nums2```ì—ì„œ ë°›ì•„ì™€ì„œ
forë¬¸ìœ¼ë¡œ ë„£ì–´ì£¼ëŠ” ë°©ì‹ì…ë‹ˆë‹¤.
ë³‘í•© í›„ ë§ˆì§€ë§‰ ì •ë ¬ì€ ```Arrays.sort``` ë©”ì„œë“œë¡œ ì •ë ¬í–ˆìŠµë‹ˆë‹¤.
+ ì‹œê°„ë³µì¡ë„: O(n + m * log(m+n))
+ ê³µê°„ë³µì¡ë„: O(1)

#### 3. ë‹¤ë¥¸ ì‚¬ëŒì˜ í’€ì´ë¥¼ ë³´ê³  ê°œì„ í•˜ê¸°
```java
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        int i = m - 1;
        int j = n - 1;
        int k = m + n - 1;
        
        while (j >= 0) {
            if (i >= 0 && nums1[i] > nums2[j]) {
                nums1[k--] = nums1[i--];
            } else {
                nums1[k--] = nums2[j--];
            }
        }
    }
}
```
ë‹¤ë¥¸ í’€ì´ ì¤‘ì— ê°€ì¥ ê¹”ë”í•˜ê³  ì‹ ì„ í–ˆë˜ ì ‘ê·¼ì´ì—ˆìŠµë‹ˆë‹¤. ë‘ í¬ì¸í„°ë¥¼ ë‘ê³  í‘¸ëŠ” í’€ì´ê³  ì‹œê°„ë³µì¡ë„ê°€ ```O(n+m)```ìœ¼ë¡œ ê°œì„ ë©ë‹ˆë‹¤.
+ ë³€ìˆ˜ i, j, kë¥¼ ê°ê° ```nums1```, ```nums2```, ```ë³‘í•©í•œ nums2```ì˜ ì¸ë±ìŠ¤ë¡œ ì´ˆê¸°í™”í•©ë‹ˆë‹¤.
+ ì£¼ì–´ì§„ ë°°ì—´ì´ ì´ë¯¸ ì •ë ¬ë˜ì–´ ìˆë‹¤ëŠ” íŠ¹ì§•ì„ í™œìš©í•˜ì—¬, í° ê°’ë“¤ì„ ë’¤ì—ì„œë¶€í„° ìˆœì°¨ì ìœ¼ë¡œ ```nums1``` ë°°ì—´ì— ì±„ì›Œ ë„£ìŠµë‹ˆë‹¤.
+ ë³‘í•©ì‹œ ë” í° ê°’ì„ ```nums1``` ë°°ì—´ì˜ ëë¶€í„° ì‹œì‘í•˜ëŠ” ì¸ë±ìŠ¤ kì— ì €ì¥í•©ë‹ˆë‹¤. ë§Œì•½ ```nums1``` ë°°ì—´ì˜ ìš”ì†Œê°€ ```nums2``` ë°°ì—´ì˜ ìš”ì†Œë³´ë‹¤ í¬ë‹¤ë©´ í•´ë‹¹ ìš”ì†Œë¥¼ ë¨¼ì € ```nums1[k]``` ìœ„ì¹˜ì— ì €ì¥í•˜ê³ , ê·¸ë ‡ì§€ ì•Šì€ ê²½ìš°ì—ëŠ” ```nums2[j]``` ê°’ì„ ```nums1[k]``` ìœ„ì¹˜ì— ì €ì¥í•©ë‹ˆë‹¤.
+ ê°ê°ì˜ ë°°ì—´ ìš”ì†Œë¥¼ ì²˜ë¦¬í•  ë•Œë§ˆë‹¤, i, j, ê·¸ë¦¬ê³  kë¥¼ ê°ì†Œì‹œí‚µë‹ˆë‹¤.
+ ```nums2``` ë°°ì—´ì˜ ìš”ì†Œë¥¼ ëª¨ë‘ ```nums1``` ë°°ì—´ì— í•©ì¹  ë•Œê¹Œì§€ ìœ„ì˜ ê³¼ì •ì„ ë°˜ë³µí•©ë‹ˆë‹¤.

#### 4. ìƒê°í•´ ë³¼ ë¶€ë¶„
í¬ì¸í„°ë¥¼ ì´ìš©í•œ ì ‘ê·¼ë²•ì— ëŒ€í•´ ìƒê°í•´ë³´ì§€ ëª»í–ˆëŠ”ë° ì‹œê°„ë³µì¡ë„ë¥¼ ê³ ë ¤í•´ ìƒˆë¡œìš´ ì ‘ê·¼ë²•ì„ ìµíˆê²Œ ëœ ê³„ê¸°ê°€ ë˜ì—ˆìŠµë‹ˆë‹¤.
```Arrays.sort```ë¥¼ ì´ìš©í•œ í’€ì´ê°€ ì‹œê°„ë³µì¡ë„ê°€ ë†’ì•„ì§„ë‹¤ëŠ” ê²ƒì„ í™•ì¸í•  ìˆ˜ ìˆì—ˆìŠµë‹ˆë‹¤.   
ê·¸ë¦¬ê³  return ê°’ì´ ë³„ë„ ì¡´ì¬í•˜ì§€ ì•Šê³  ```nums1```ì— ê°’ì— ë³‘í•©ì²˜ë¦¬í•œë‹¤ëŠ” ì „ì œê°€ ë‹¤ë¥¸ ì½”ë“œí…ŒìŠ¤íŠ¸ ì‚¬ì´íŠ¸ì™€ ì°¨ì´ê°€ ìˆì–´ ë¬¸ì œë¥¼ ë” ì˜ ì½ì–´ì•¼ê² ë‹¤ëŠ” ìƒê°ì´ ë“¤ì—ˆìŠµë‹ˆë‹¤.

<div style="padding:3px; margin:200px 0;"></div>   
