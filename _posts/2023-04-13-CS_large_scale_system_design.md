---
title: 📖 가상면접 사례로 배우는 대규모 시스템 설계 기초 (진행중)
author: Rosie Yang
date: 2023-04-13
category: cs
layout: post
---

> 토의 스터디로 진행된 학습내용을 정리한 포스트입니다. [github](https://github.com/BacknPacker/large_scale_system_design.git)

<br>

### Contents
<table>
    <tr>
        <td style="width:30%;">
            <img src="/assets/gitbook/post_images/cs/large_scale_system_design.jpg">
        </td>
        <td>
            <ul>
                <li><a href="/cs/2023/04/13/CS_large_scale_system_design.html#1장-사용자-수에-따른-규모-확장성">1장. 사용자 수에 따른 규모 확장성</a></li>
                <li><a href="/cs/2023/04/13/CS_large_scale_system_design.html#2장-개략적인-규모-추정">2장. 개략적인 규모 추정</a></li>
            </ul>
        </td>
    </tr>
</table>

<br><br>

### 1장. 사용자 수에 따른 규모 확장성
> 최근에 정리한 [백엔드 설계시 고려해야할 사항](/cs/2023/04/14/Architecture.html#백엔드-아키텍처-설계시-고려사항)에 대한 포스팅과 유사한 부분이 많았습니다.  

**단일서버**  
만약 사용자가 도메인 주소를 입력하면, 어떻게 될까요?  
DNS에서 해당하는 IP주소를 찾고 그 주소에 해당하는 웹서버에 HTTP 요청을 보내게 됩니다. 이 때, 웹서버는 요청에 따른 HTML 또는 JSON 데이터 정보를 사용자 단말에 보여주게 됩니다.  

**데이터베이스**  
HTTP 요청을 받은 웹서버는 데이터베이스를 통해 데이터를 얻게 됩니다. 데이터베이스는 관계형 데이터베이스인 MySQL, PostgreSQL 등이 있고, 비관계형 데이터베이스인 NoSQL에는 DynamoDB, Redis 등이 있습니다. NoSQL은 키-값 저장소, 그래프 저장소, 칼럼 저장소, 문서 저장소로 나눌 수 있습니다.   
비관계형 데이터베이스는 <span style="background-color:#fff5b1">비정형 데이터이거나 데이터를 단순히 직렬화, 역직렬화만 하면 되는 상황, 아주 낮은 지연 응답시간이 요구되는 상황에 적합합니다. 또는 아주 많은 양의 데이터를 저장할 필요가 있을 때 사용됩니다.</span>  

<span style="background-color:#DCFFE4">아주 많은 데이터를 저장한다는 것은 쓰기 연산이 요구되는 부분이 아닌가요?</span>   
기존에 NoSQL에 대해 공부할 때, 매번 데이터 조회를 RDBMS에서 하는 것이 아니라 Redis를 이용한 캐싱처리 방안을 모색한 적이 있습니다. 이 때는 읽기 연산을 위한 수단이었는데, 비휘발성 메모리에 많은 양의 데이터를 저장하기 위해 사용한다는 말이 이해되지 않았습니다.  
저자의 의도를 생각해 보면, 데이터를 저장하는 과정에서 NoSQL에 먼저 저장해 두고, RDBMS에는 일정 시간마다 데이터 업데이를 진행하는 부분이라고 이해했습니다. 이렇게 하면 읽기 작업을 RDBMS로 진행한다고 했을 때, 특정 row를 읽기 위해 row lock 걸리는 상황에서도 많은 데이터의 일시 저장으로 인해 상당 시간 page lock이 걸리는 등의 경합이 발생하지 않을 수 있기 때문입니다.  

**수직적 규모 확장 vs 수평적 규모 확장**  
서버를 확장하는 방법은 수직적 규모 확장과 수평적 규모 확장으로 나눌 수 있습니다.  
수직적 규모 확장은 ```scale-up```이라고도 하며, 서버 자체의 CPU나 메모리를 증설하는 방법입니다. 하지만 서버 증설을 무한정할 수 없으며, 이 서버만 존재한다면, 장애 상황에서 자동복구나 다중화 방안을 제시하지 못한다는 점에서 한계를 가지고 있습니다.  
수평적 확장은 ```scale-out```이라고도 하며, 여러 서버를 두어 성능을 개선하는 방법을 말합니다. 이렇게 여러 서버를 가지고 가면, 로드밸런서로 서버 접속을 적절히 분산해 성능 향상과 부하를 방지할 수 있습니다. 
로드밸런서는 보안을 위해 사설 IP 주소를 사용해 서버 간 통신을 하며, 요청을 먼저 받아 사설 IP 주소의 웹서버에 연결해줍니다.  
그럼 데이터베이스의 다중화 처리는 어떨까요?  
데이터베이스는 주 데이터베이스와 부 데이터베이스로 나누어 주로 애플리케이션에 많이 사용되는 읽기 작업은 여러 부 데이터베이스에서 하게 하고, 쓰기 작업은 주 데이터베이스에서 처리합니다.  
부 데이터베이스 장애시, 주 데이터베이스 또는 새로운 부 데이터베이스에서 읽기 작업을 이어서 하게 됩니다. 주 데이터베이스 장애시에는 부 데이터베이스가 주 데이터베이스의 역할을 하게 됩니다. 그리고 보관 데이터가 최신 상태가 아닌 경우 복구 스크립트로 추가적인 해결이 필요합니다.  

<span style="background-color:#DCFFE4">복구 스크립트를 이용한 추가해결이 가능할까?</span>  
이미 주 데이터베이스가 장애가 나서 부 데이터베이스를 주 데이터베이스로 승격하는 과정에서 필요한 부분은 쓰기 연산이 진행되는 주 데이터베이스의 데이터와의 일관성입니다. 따라서 주 데이터베이스의 데이터를 가지고 올 수 있다면, 부 데이터베이스에 주 데이터베이스 장애 바로 직전으로의 복구된 데이터를 가지고 올 수 있어야 합니다.  

<span style="background-color:#DCFFE4">다중 마스터와 원형 다중화</span>

**캐시**  
<span style="background-color:#fff5b1">캐시는 값비싼 연산 결과 또는 자주 참조되는 데이터를 메모리에 두어 연이은 요청이 빨리 처리될 수 있도록 하는 저장소를 말합니다.</span> 데이터베이스 조회보다 빠르게 데이터를 가지고 올 수 있습니다. 
사용자가 요청을 보내면 캐시에 값이 있으면 그 데이터를 넘기고 없으면 데이터베이스에 조회해 캐시 저장 후 요청을 처리하게 됩니다.  
캐시는 주로 참조 데이터에 사용하며, 만료시 데이터를 다시 데이터베이스에서 읽어와야 하므로 만료기간을 너무 짧게 두어선 안됩니다. 또 만료기간이 너무 길 경우에는 캐시와 데이터베이스 간의 일관성이 떨어집니다. 
그리고 캐시 역시 단일 장애지점(Single Point of Failure, SPOF)가 되지 않도록 캐시 서버를 분산시켜야 합니다.  

<span style="background-color:#DCFFE4">캐시 방출정책</span>

<span style="background-color:#DCFFE4">캐시 일관성에 대한 페이스북 논문</span>

**콘텐츠 전송 네트워크 (CDN)**  
CDN은 정적 콘텐츠 전송에 쓰이는 네트워크로 가까운 CDN 서버를 통해 정적 콘텐츠를 얻고 해당 지리적 위치의 CDN에 소스가 없다면, 그 CDN에 원본 서버에서 가지고 온 정적 콘텐츠를 저장 후, 가지고 오게 됩니다. CDN을 사용할 때는 비용과 콘텐츠의 만료시점, 장애대처 방안 그리고 버전 관리를 이용한 콘텐츠 무효화 등을 고려해야 합니다.  

**무상태 웹 계층**  
사용자의 상태정보를 웹 서버에서 관리한다면, 그리고 웹 서버가 여러 개라면 로드밸런서는 해당 사용자를 상태를 가지고 있는 웹서버로만 연결해야 합니다. 물론 이를 돕기 위해 고정 세션(sticky session)을 이용하면 되자만, 이 경우 로드밸런서에 부담을 주게 됩니다.  
따라서 무상태 웹 계층으로 아키텍처를 만들 필요가 있는데 이렇게 되면 사용자는 어떤 웹 서버에 요청을 보내든지 응답을 받을 수 있게 됩니다. 무상태 아키텍처에서는 상태 정보가 웹 서버에 있지 않아 규모의 축소/확장이 자유로워집니다.  

**데이터 센터**  
데이터 센터는 ```US-East```, ```US-West```와 같이 지리적 라우팅에 따라 geoDNS로 가까운 IP주소로 연결해주는 서비스입니다. 
여러 개의 데이터 센터를 사용하고자 할 때는 각 데이터 센터의 위치에서 서비스가 잘 동작하는지 테스트할 필요가 있고, 각 데이터 센터별 데이터 일관성이 유지되는지 확인할 필요가 있습니다.  

**메시지 큐**  
<span style="background-color:#fff5b1">메시지 큐는 무손실을 보장하는 비동기 통신을 지원하는 컴포넌트입니다.</span> 발행자는 미리 메시지 큐를 만들어두고, 소비자가 소비할 때마다 큐에 있는 동작을 수행하게 됩니다. 
생산자는 소비자의 프로세스가 없더라도 메시지를 발행할 수 있고, 소비자 역시 생산자가 가용한 상태가 아니여도 메시지를 수신할 수 있습니다. <span style="background-color:#fff5b1">각 컴포넌트가 느슨한 결합이 될 수 있도록 하고, 결함에 대한 내성을 높입니다.</span>  
책에서는 사진 보정 작업을 미리 메시지 큐로 만들어두고 비동기적으로 완료할 수 있도록 하는 프로세스를 예시로 들고 있습니다.  

<span style="background-color:#DCFFE4">큐의 크기가 커지면 더 많은 작업 프로세스를 추가해야 처리 시간을 줄일 수 있습니다. 하지만 큐가 거의 항상 비어있는 상태라면 작업 프로세스의 수는 줄일 수 있을 것입니다.</span>

<span style="background-color:#DCFFE4">메시지 큐</span>

**로그, 메트릭 그리고 자동화**  
시스템 규모가 커질수록 로그, 메트릭, 자동화는 중요합니다. 여기서 메트릭이란 사업 현황이나 시스템 현재 상태를 파악할 수 있는 중요한 도구입니다. 예를 들어, CPU, 메모리 등에 대한 호스트 단위 메트릭, 데이터베이스나 캐시 성능에 관한 종합 메트릭, 일별 능동사용자, 재방문 등과 같은 핵심 비즈니스 메트릭이 있습니다.  

**데이터베이스의 규모 확장**  
데이터베이스 규모 확장도 수직적, 수평적 규모 확장이 있습니다. 앞서 서버의 경우의 수직적 확장과 거의 유사한 단점을 가지고 있습니다.  
여기서 눈여겨 봐야할 부분은 데이터베이스의 수평적 확장입니다. <span style="background-color:#fff5b1">데이터베이스의 수평적 확장은 샤딩이라고 하며, 샤드 단위로 분할해 중복이 없도록 관리합니다.</span> 
샤드를 분리하는 기준에 따라 분포가 균등하지 않을 수도 있고, 특정 데이터베이스에 핫스팟 키가 집중되어 서버 과부하가 발생할 수 있습니다. 따라서 이 경우에는 재 샤딩을 하거나 오히려 비정규화로 여러 샤드에서 조인하는 과정에서 오는 비효율을 방지하는 것 등을 고려해야 합니다.  

**백만 사용자, 그리고 그 이상**  
큰 규모의 시스템을 관리하기 위해서는 최적화하고 작은 단위로 서비스를 분할하는 등 확장성에 유리한 설계가 필요합니다. 
+ 웹 계층은 무상태 계층으로
+ 모든 계층에 다중화 도입
+ 가능한 한 많은 데이터 캐시할 것
+ 여러 데이터 센터를 지원할 것
+ 정적 콘텐츠는 CDN을 통해 서비스할 것
+ 데이터 계층은 샤딩을 통해 그 규모를 확장할 것
+ 각 계층은 독립적 서비스로 분할할 것
+ 시스템을 지속적으로 모니터링하고, 자동화 도구들을 활용할 것

<span style="background-color:#DCFFE4">참고문헌</span>

<br><br>

### 2장. 개략적인 규모 추정
> 개략적인 규모 추정은 보편적으로 통용되는 성능 수치상에서 사고 실험을 행하여 보편적으로 통용되는 성능 수치상에서 사고 실험을 행하여 추정치를 계산하는 행위로서, 어떤 설계가 요구사항에 부합할 것인지 보기 위한 것  
> Jeff Dean, Lead of Google AI

**고가용성**  
시스템이 오랜 시간 동안 지속적으로 중단 없이 운영될 수 있는 능력을 지칭하는 용어입니다. (대부분 99% ~ 100%)  
**SLA(Service Level Agreement)**  
서비스 사업자가 보편적으로 사용하는 용어, 서비스 사업자와 고객 사이에 맺어진 합의  

<table>
    <tr>
        <td>
            <img src="/assets/gitbook/post_images/cs/20230718_213814.png">
        </td>
        <td>
            <img src="/assets/gitbook/post_images/cs/20230718_213845.png">
        </td>
    </tr>
</table>

**추정량 구하기**  
트위터 QPS와 저장소 요구량 추정 예시  
+ 월간 능동 사용자 수 3억명
+ 50% 사용자가 트위터를 매일 이용
+ 평균적으로 각 사용자는 매일 2건의 트윗을 올림
+ 미디어를 포함하는 트윗은 10%
+ 데이터는 5년간 보관

| 추정치                       | 계산식                                                     |
|---------------------------|---------------------------------------------------------|
| QPS(Query Per Second) 추정치 | (1.5억명\*2트윗)/(24\*60*60) = 약 3500                       |
| 미디어 저장을 위한 저장소 요구랑        | (1.5억\*2트윗\*10%)\*1MB = 30TB/일 <br> 30TB\*365*5 = 약 55PB |

**추정치 계산을 위한 팁**  
1. 근사치를 이용해서 계산
2. 가정을 적어두자
3. 단위를 붙이자
4. QPS, 최대 QPS, 저장소 요구량, 캐시 요구량, 서버 수 문제를 익혀두자

<span style="background-color:#DCFFE4">참고문헌</span>

****
+ [Uptime/SLA calculator: what is an SLA and how to calculate it?](https://pandorafms.com/blog/what-is-an-sla/)  


<div style="padding:3px; margin:200px 0;"></div>   