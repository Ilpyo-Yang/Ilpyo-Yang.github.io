---
title: JPA
author: Rosie Yang
date: 2023-04-15
category: spring
layout: post
---

## JPA에 대하여
JPA는 Java Persistence API로 자바 플랫폼 SE와 자바 플랫폼 EE를 사용하는 응용프로그램에서 <span style="background-color:#fff5b1">관계형 데이터베이스의 관리(ORM 기술 표준)를 표현하는 자바 API</span>입니다. 여기서 ORM(Object Relational Mapping)이란 객체와 데이터베이스의 관계를 매핑해주는 도구로 자바 외 언어에서는 node.js에서의 ```Sequelize```, python 기반 Django에서 지원하는 ```Django ORM``` 등이 있습니다.

![jpa_operation.png](/assets/gitbook/post_images/jpa/jpa_opertaion.png)

JPA는 애플리케이션과 JDBC 사이에서 동작하며 SQL 작성으로 인한 개발시간을 단축할 수 있다는 장점이 있습니다. JPA를 사용하면 Entity 분석하고 SQL 생성한 뒤, JDBC API 사용하고 패러다임의 불일치까지 해결해 줄 수 있습니다.  

<span style="background-color:#DCFFE4">JPA는 패러다임의 불일치를 어떻게 해결할까?</span>  
패러다임의 불일치는 객체와 관계형 데이터베이스 사이의 불일치 의미합니다. 관계형 데이터베이스에는 테이블로 데이터를 관리하고 객체 지향 프로그래밍은 객체 단위로 상속, 다형성 개념을 가지고 관리합니다. 대표적인 불일치로 사례들은 <span style="background-color:#fff5b1">상속, 연관관계, 객체 그래프 탐색, 식별자</span> 등이 있습니다. JPA에서는 다양한 매핑 어노테이션과 매핑 설정, 그리고 지연로딩, 즉시로딩을 이용해 패러다임의 불일치를 최소화하고 있습니다.  

<br>

**JPA 성능 최적화 기능**  
<span style="background-color:#fff5b1">1차 캐시와 동일성 보장합니다.</span> 같은 트랜잭션 안에서 같은 엔티티를 반환하고 ```Read Commit``` 격리수준에서도 애플리케이션에서 ```Repeatable Read```를 보장합니다.  
<span style="background-color:#fff5b1">트랜잭션을 지원하는 쓰기 지연을 제공합니다.</span> 트랜잭션이 끝날 때까지 Insert SQL을 모아서 한 번에 Commit 처리합니다.   
<span style="background-color:#fff5b1">지연로딩과 즉시로딩을 지원합니다.</span> 연관된 객체까지 미리 조회하는 것을 즉시로딩이라고 합니다. 반면, 지연로딩은 객체가 실제 사용될 때 로딩되는 방식입니다.  

<br>

**데이터 중심 설계와 엔티티 설계의 차이점**  
데이터 중심 설계는 테이블의 외래키를 객체에 그대로 가지고 오는 방식으로 만들어져 있습니다. 이렇게 하게 되면, 객체 그래프 탐색이 불가능해지고, 참조가 없어 UML도 잘못 작성됩니다.  
따라서 먼저 자바 객체인 엔티티를 설계하고 테이블을 생성하는 방식을 사용해야 합니다. 외래키가 아닌 참조할 키의 값을 가지고 와서 하나의 컬럼

****
[Spring Data JPA - Reference Documentation](https://docs.spring.io/spring-data/jpa/docs/current/reference/html/)

<br><br>

## 영속성 컨텍스트(persistence context)
**JPA의 모든 기능은 Transaction 안에서 수행해야 합니다.**  
이는 JPA가 영속성 컨텍스트(persistence context)를 사용하여 엔티티의 상태를 추적하고, 데이터베이스와의 일관성을 유지하기 위해 필요합니다. <span style="background-color:#fff5b1">영속성 컨텍스트는 JPA에서 엔티티 객체를 관리하는 메모리 영역</span>이며, 엔티티의 상태를 추적하고 변경사항을 데이터베이스에 반영합니다. 트랜잭션을 사용하지 않으면 영속성 컨텍스트가 데이터베이스와의 일관성을 유지할 수 없게 되어, 데이터 불일치 문제가 발생할 수 있습니다.  
영속성 컨텍스트를 사용하므로써 <span style="background-color:#fff5b1">1차 캐시</span>에서 조회한 뒤, 없으면 DB 조회하고 1차 캐시에 반영합니다. 그리고 요청값을 반환합니다. 즉, 1차 캐시로 ```Repeatable Read``` 등급의 트랜잭션 격리수준을 애플리케이션 차원에서 한 트랜잭션 안에 수행하며, 매번 사용되는 것이 아니라 큰 성능상의 이점은 없지만, 한 트랜잭션이 길고 반복조회가 많다면 1차 캐시를 이용한 영속성 컨텍스트의 효과를 볼 수 있습니다.  
(참고로 모든 고객이 같은 캐시로 성능적 효과를 보는 것은 이와 별개로 2차 캐시라고 합니다.) 
```java
EntityManager em = emf.createEntityManager();
EntityTransaction transaction = em.getTransaction();
transaction.begin();

em.persist(memberA);
em.persist(memberB);

transaction.commit();   

// em.persist(memberA); 첫 번째 SQL만 생성되서 조회하는 것을 확인할 수 있습니다.
// 이후 내용은 1차 캐시에서 조회하기 때문

em.detach(member);  // 준영속, 영속성 컨테스트에서 분리
em.remove(member);  // 객체를 삭제한 상태
```  
<span style="background-color:#DCFFE4">준영속 상태란?</span>  
JPA가 관리하는 상태인 1차 캐시에 있는 상태는 영속성 상태라고 할 수 있습니다. 반면, 준영속 상태는 영속성 컨텍스트에서 분리된 것으로 JPA가 관리하는 상태가 아닙니다. 따라서 항상 변경 감지를 사용해서 entity를 관리할 필요가 있습니다. 실무에서는 데이터베이스의 특정 테이블에 대한 일시적인 변경이 필요한 경우, 준영속 상태를 사용하여 일시적 변경 후 되돌리는 경우가 있습니다.  

<br>

### 영속성 컨텍스트의 이점
1차 캐시만을 사용하며, 영속성 컨텍스트는 조회시 같은 객체를 불러온다는 점에서 <span style="background-color:#fff5b1">동일성을 보장</span>해줍니다. <span style="background-color:#fff5b1">트랜잭션을 지원하는 쓰기지연으로 영속성 컨텍스트를 플러시하기 전까지 데이터베이스 락이 걸리는 시간을 최소화</span>합니다. 지연로딩을 이용해서 연관관계를 <span style="background-color:#fff5b1">패러다임 불일치를 감소</span>시킵니다. 그리고 <span style="background-color:#fff5b1">변경감지(dirty check)</span>를 하기 때문에 스냅샷 정보와 바뀐 entity 정보를 비교해서 변경 부분을 커밋시에 업데이트해줍니다.  

<span style="background-color:#DCFFE4">쓰기 지연 SQL 저장소는 왜 필요할까?</span>  
쓰기 지연은 한 트랜잭션에서 일어나는 update, save 쿼리를 가지고 있다가 최종적으로 commit이 일어나는 시점에 한 번에 DB에 반영하는 것을 말합니다. <span style="background-color:#fff5b1">Persistance Storage</span>는 이런 쓰기 지원 기능을 가지고 있습니다. 따라서 Persistance Context 하에 관리되고 있던 entity의 변화들을 감지, 추적하고 이를 Persistance Storage에 반영한 뒤 최종적으로 DB에 반영할 수 있도록 합니다.  

<span style="background-color:#DCFFE4">플러시가 뭘까?</span>  
영속성 컨텍스트의 변경내용을 데이터베이스에 반영하는 것을 말합니다. 커밋이나 쿼리 실행시 자동으로 플러시가 발생하며(```FlushModeType.AUTO```, 기본값), 쓰기 지연 SQL 저장소의 쿼리를 데이터베이스에 전송합니다. 직접 호출하는 경우에는 ```em.flush()```를 이용할 수 있습니다. 플러시 자체는 영속성 컨텍스트를 비우지 않고 변경내용을 데이터베이스에 동기화합니다.   
참고로 JPA는 기본적으로 데이터를 맞추거나 동시성 관련된 것을 데이터베이스 트랜잭션에 위임합니다.  

****
[자바 ORM 표준 JPA 프로그래밍 - 기본편](https://www.inflearn.com/course/ORM-JPA-Basic/dashboard)  
[Object Persistence with JPA](https://thistechnologylife.com/object-persistence-with-jpa/)  
[[JPA] 준영속 상태와 변경 감지](https://velog.io/@wogud7587/JPA-%EC%A4%80%EC%98%81%EC%86%8D-%EC%83%81%ED%83%9C%EC%99%80-%EB%B3%80%EA%B2%BD-%EA%B0%90%EC%A7%80)

<br><br>

## 데이터베이스 스키마 자동생성
JPA는 데이터베이스를 자동으로 생성해주도록 ```ddl-auto``` 옵션을 설정할 수 있습니다. 옵션의 종류는 ```create```, ```create-drop```, ```update```, ```none```, ```validate``` 종류가 있습니다. 주로 개발환경이나 테스트 서버에서는 ```update```를 사용해야 하고 실서버에서는 절대 사용하면 안됩니다. 주로 운영서버에서는 ```validate```나 ```none```을 사용합니다. ```validate```는 엔티티와 테이블이 정상 매핑되었는지만 확인합니다. ```none```이라는 개념은 실제 없고, 주석처리하는 것과 동일한 효과를 갖습니다.
```yml
jpa:
  hibernate:
    ddl-auto: create
```
<span style="background-color:#DCFFE4">DDL 생성기능은 DDL을 자동 생성할 때만 사용되고 JPA의 실행로직에는 영향을 주지 않습니다.</span> 즉 ```validation``` 용도로 사용하기에 좋습니다.

<br><br>

## 엔티티 매핑
**@Entity, @Table**
```java  
@Entity
@Table(name="TABLE", schema="NAME", 
        uniqueConstraints={@UniqueConstraint(name="unique_pid", columnNames="PersonalId")})
public class Table {
    // Entity 속성 생략    
}
``` 
**@Column**  
```@Column(name="location", length=20, nullable=false)```  
unique 제약여부도 걸 수 있지만, unique 제약의 이름을 설정하기 어렵기 때문에 ```@Table``` 위에 코드처럼 직접 설정해주는 것을 권장합니다.  
name을 설정할 때는 별도 지정이 없이도 스프링부트에서는 자바의 ```Carmel Case``` 이름을 ```Snake Case```로 변경해서 자동 매핑할 수 있는데, 직접 코드로 설정도 가능합니다. ```spring.jpa.hibernate.naming.physical-strategy``` 속성을 ```org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl``` 클래스로 설정하고, ```spring.jpa.hibernate.naming.physical-strategy``` 속성을 오버라이드하여 스네이크 케이스로 변환하는 클래스를 작성해야 합니다.   
```properties
// 직접 구현시 -> 오버라이드
spring.jpa.hibernate.naming.physical-strategy=org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl
// 자동 구현시 설정
spring.jpa.properties.hibernate.physical_naming_strategy=com.example.SnakeCaseNamingStrategy
```

**@Enumerated**  
```@Enumerated(value = EnumType.STRING)```  
기본값인 EnumType.ORDINAL을 사용하면 enum 순서를 저장합니다.  

**@Temporal**  
날짜 타입을 매핑할 때 사용되며, TemporalType은 date, time, timestamp로 나뉩니다. Date, Calendar 매핑에 사용하며, ```LocalDateTime```, ```LocatlDate```의 경우에는 생략이 가능합니다.  

**@Transient**  
특정 필드를 컬럼에 매핑하지 않을 경우로 메모리 상에 어떤 값을 임시로 저장하고 싶은 경우에 사용됩니다.  

**@Lob**  
Large Object의 줄임말로 스프링이 추론하여 어떤 타입으로 저장할지를 판단할 때 사용하며, 문자는 ```BLOB```으로 나머지는 ```CLOB``` 타입과 매핑합니다.

**@Id**  
기본키를 직접 매핑하는 경우에 사용됩니다.  

**@GeneratedValue**  
기본키를 자동으로 생성해주는 어노테이션으로 ```GenerationType``` 전략은 4가지가 있습니다.
+ ```IDENTITY``` 
  + 기본키 생성을 데이터베이스에 위임하는 전략입니다. ```em.persist()``` 시점에 즉시 insert하고 db 식별자를 조회해옵니다.   
  + MySQL은 ```AUTO_INCREMENT``` 값을 저장하고 나서 기본키를 구할 수 있을 때 사용됩니다.  
  + <span style="background-color:#fff5b1">이 전략에서는 트랜잭션을 지원하는 쓰기 지연이 동작하지 않습니다.</span>  
+ ```SEQUENCE```  
  + ```@SequenceGenerator``` 시퀀스를 이용해서 기본키를 생성하는데, 시퀀스를 지원하는 데이터베이스에서 사용이 가능합니다.  
+ ```TABLE```
  + 키 생성용 테이블을 사용하는 경우입니다.
+ ```AUTO```
  + 방언에 따라 자동지정되며, 기본값입니다. 

```GenerationType``` 전략을 사용할 때는 주의가 필요합니다. Hibernate 버전별 전략에 따라 기본키 자동 생성이 설정 값과 다르게 적용될 수 있다는 문제를 실제 겪은 적이 있는데 잘 정리된 [블로그 글](https://jojoldu.tistory.com/295)이 있어서 추가합니다.  

****
[[JPA] 기본 키(Primary Key)매핑](https://ttl-blog.tistory.com/123)  
[Spring Boot Data JPA 2.0 에서 id Auto_increment 문제 해결](https://jojoldu.tistory.com/295)

<br><br>

## 연관관계 매핑
> 다중성, 단방향VS양방향, 연관관계의 주인

JPA를 처음 배우는 사람들이 가장 헷갈리고 어렵게 느낄 수 있는 부분일 것 같다고 생각합니다. 이하 내용은 [김영한님 인프런 로드맵](https://www.inflearn.com/roadmaps/149) 학습내용을 기반으로 연관관계 매핑에 대해 정리했습니다.  
연관관계란 데이터베이스에서 외래키로 RDB 관계를 설정하는 것처럼 객체지향 설계에서 객체를 참조하는 방식을 이야기합니다. 연관이 있는 관계, 예를 들면, 어떤 반에 속하는 학생이 여러 명이라면 그 반과 학생들은 ```1:N 매핑```으로 설명할 수 있습니다. 이렇게 JPA에서는 연관관계를 외래키가 없이 객체의 참조 방식으로 연관을 지을 수 있는 방법을 제공합니다.  

**연관관계 매핑시 고려사항**  
연관관계는 크게 단방향과 양방향 매핑으로 나뉩니다. 단방향은 말 그래도 한 쪽에서 다른 관계를 참조하는 것이고, 양방향은 양쪽에서 참조가 가능합니다. 연관관계에서는 주인을 정하고 주인이 아닌 방향에서는 단순 읽기를 위해 주로 참조를 걸지만, 실무에서는 양쪽의 데이터를 간편하게 가지고 오기 위해 양방향 매핑이 많이 사용됩니다.  
<span style="background-color:#fff5b1">연관관계의 주인은 외래키가 있는 테이블(N)과 매핑되는 entity에 설정하는 것을 권장됩니다. 그 반대쪽에는 ```MappedBy```로 관계를 알 수 있는 변수명을 매핑해주어야 합니다.</span>  
연관관계를 사용할 때는 순수 객체 상태를 고려해서 항상 양쪽에 값을 설정하는 것이 좋습니다. 따라서 한 쪽 entity의 setter 메서드 대신 연관관계의 반대에도 자동으로 set이 될 수 있도록 알아보기 쉬운 메서드를 따로 지정해주는 것이 좋습니다. 그래야 양쪽 다 값을 잊지 않고 설정하기에 편리합니다.  

<br>

### 종류와 전략
**다대일 [N:1]**  
매핑으로는 ```다대일 양방향```으로 사용하는 것을 추천합니다. 맨 처음 예시로 들었던 학생과 반에 대한 연관관계 entity를 코드로 작성했습니다. 아래 코드에서는 ```다대일 양방향 매핑```이 된 상태입니다.
```java
// 학생 entity
@ManyToOne
@JoinColumn(name="TEAM_ID")
private Team team;
```
<span style="background-color:#DCFFE4">@JoinColumn에 대하여</span>  
외래키를 매핑할 때 사용합니다. ```@JoinColumn```을 쓰지 않으면 ```@JoinTable``` 전략으로 동작하기 때문에 불필요한 테이블이 하나 더 생기고 관리하기에 비효율적입니다.  

**일대다 [1:N]**  
다대일과 달리 ```mappedBy``` 속성이 있습니다. 
```java
// 팀 entity
@OneToMany(MappedBy="student")
@JoinColumn(name="STUDENT_ID")
private List<Student> students = new ArrayList<>();
```

**일대일 [1:1]**  
```일대일 양방향```은 ```다대일 양방향``` 매핑과 유사합니다. 하지만 일대일이기 때문에 어느 방향에 외래키를 넣어도 되지만, 향후 기능 추가와 DBA와의 협업으로 어떻게 주인을 설정할지 고민해봐야 합니다. 일반적으로 전통적인 데이터베이스 설계와 동일하게 대상테이블에 외래 키를 넣는 방식으로 하면, 나중에 일대다 매핑으로 변경시에도 테이블 구조가 유지된다는 장점이 있습니다. 하지만, 프록시 기능의 한계로 지연로딩으로 설정해도 항상 즉시로딩된다는 단점이 있습니다.      
```java
// 팀 entity
@OneToOne(MappedBy="student")
@JoinColumn(name="STUDENT_ID")
private Student student;

// 학생 entity
@OneToOne
@JoinColumn(name="TEAM_ID")
private Team team;
```

**다대다 [N:M]**  
관계형 데이터베이스에서는 표현할 수 없는 방식으로 실무에서 사용하지 않습니다. 중간 테이블을 만들어 일대다 또는 다대일 관계로 만들어야 합니다. 하지만 중간테이블을 따로 관리하는 것보다 차라리 중간테이블을 entity로 승격해서 관리하는 것을 권장됩니다.  
```java
@ManyToMany(fetch=LAZY)
@JoinTable(name="CATEGORY_ITEM",
  joinColumn=@JoinColumn(name="CATEGORY_ID"),
  inverseJoinColumns=@JoinColumn(name="ITEM_ID")      
)
private List<Item> items = new ArrayList<>();
```

<br>

**즉시로딩과 지연로딩**  
연관관계 속성에서 fetch 전략을 ```fetchType.LAZY```으로 지연로딩으로 선택하거나, ```fetchType.EAGER```으로 즉시로딩을 설정할 수 있습니다. 하지만 즉시로딩을 할 경우 성능이 나빠지거나 예상치 못한 쿼리들이 발생하기 때문에 사용을 피하는 것이 좋습니다. <span style="background-color:#FFE6E6">```@ManyToOne```, ```@OneToOne```은 기본값이 즉시로딩이므로 ```@ManyToOne(fetch=fetchType.LAZY)```와 같이 반드시 지연로딩 설정해서 위험을 방지해야 합니다.</span>  
대신 ```JPQL fetch 조인```이나 ```엔티티 그래프 기능```을 사용해서 이 문제를 해결할 수 있습니다.

<br>

**영속성 전이 CASCADE**  
<span style="background-color:#fff5b1">특정 엔티티를 영속 상태로 만들 때 연관된 엔티티도 함께 영속 상태로 만들고 싶을 때 사용됩니다.</span> 연관관계 매핑과는 아무런 관련이 없지만 ```cascade=CascadeType.PERSIST```와 같이 어노테이션 전략으로 작성되기 때문에 여기에 분류했습니다. ```CASECADE``` 종류에는 ```ALL```, ```PERSIST```, ```REMOVE```, ```MERGE```, ```REFRESH```, ```DETACH```가 있습니다. 영속성 전이가 다른 부모와 연관이 없는 자식 엔티티에만 적용하는 것이 좋습니다.  

<br>

**고아객체**  
고아객체는 부모 엔티티와 관계가 끊어진 자식 엔티티를 말합니다. ```orphanRemoval = true```와 같이 사용되는데 설정 후 부모 엔티티의 자식 리스트에서 하나를 삭제하면, 그 자식 엔티티와는 관계를 맺지 않습니다. 특정 엔티티가 개인 소유할 때만 사용하는 것이 좋습니다. ```CascadeType.REMOVE```와 같이 부모 엔티티가 삭제되는 경우, 자식 엔티티도 같이 제거됩니다.  
```CASCADE```와 고아객체를 모두 사용하면 자식 엔티티의 생명주기를 모두 관리할 수 있습니다.([DDD의 Aggregate Root 개념](https://eocoding.tistory.com/36) 구현시 유용) 

<br>

### 상속관계 매핑  
**@Inheritance**  
상속관계가 있는 entity를 만들때, JPA는 ```extends```된 엔티티를 모두 하나의 단일 테이블로 하는 전략을 기본으로 합니다. 하지만 다른 방식으로 상속매핑을 처리하고 싶은 경우에는 ```@Inheritance```의 다른 전략을 사용해주면 됩니다.
```java
@Inheritance(strategy=InherianceType.JOINED)          // 조인전략
@Inheritance(strategy=InherianceType.SINGLE_TABLE)    // 단일 테이블 전략
@Inheritance(strategy=InherianceType.TABLE_PER_CLASS) // 구현 클래스마다 테이블 전략
```
단일 테이블 전략에서는 상속된 테이블의 모든 컬럼을 가지고 있기 때문에 null을 허용해야 하는 부분이 많다는 단점이 있습니다. 테이블 간의 관계나 확장을 고려해서 중요한 설계가 필요한 경우에는 ```JOIN``` 전략을 사용하는 것이 좋습니다. ```TABLE_PER_CLASS``` 전략은 상속 매핑을 파악하기에 좋지 않기 때문에 사용하지 않는 것이 좋습니다.  

**@DiscriminatorColumn**  
부모 클래스에서 구분을 위해서 사용합니다. 단일 테이블 전략에서는 자동으로 ```@DiscriminatorColumn```를 사용하지 않아도 구분이 되는 컬럼으로 ```DTYPE```이 생성됩니다. 하지만 ```JOIN``` 전략에서는 ```DTYPE```이 생성되지 않고 하위 테이블에 제약조건이 생성되기 때문에 별도의 구분용 컬럼이 필요하지 않기 때문입니다.  

**@DiscriminatorColumn**  
자식 클래스에서 부모클래스 ```DiscriminatorColumn```용 컬럼에 들어갈 값으로 상속관계의 매핑 테이블을 구분하기 위해 사용합니다.  

**@MappedSupperclass**  
공통 매핑 속성정보를 사용하고 싶을 때를 사용합니다. 모든 테이블에 동일하게 누가 수정하고, 수정일시가 언제인지에 대한 정보가 필요하다고 한다면, ```BaseEntity```를 만들어 매핑정보만 제공할 수 있도록 합니다. 이 class는 entity는 아니고 단순히 공통 속성을 부여하기 위한 것으로 상속관계 테이블이 생성되는 개념이 아닙니다.    

<br>

### 프록시와 연관관계
실제 클래스를 상속받아서 만들어진 것으로 프록시를 이용해서 조회하는 기능인 ```em.getReference()```를 사용하는 경우 프록시 객체를 조회하며, 영속성 컨텍스트에 이미 entity가 있다면 실제 entity를 반환합니다. 참고로, ```em.find()```는 실제 객체를 조회합니다.  

<br>

**프록시 객체와 영속성 컨텍스트**  
여기서 <span style="background-color:#fff5b1">프록시 객체란 JPA에서 실제 데이터베이스 조회를 지연할 수 있게 하는 가짜 객체</span>입니다. 프록시 객체는 실제 객체를 target 변수로 가지고 있고, 조회를 하면 그 참조값으로 영속성 컨텍스트에게 초기화 요청을 보내서 실제 객체를 조회합니다. 한 번 조회된 이후에는 target 참조가 걸리기 때문에 두 번째부터는 초기화 요청을 하지 않습니다.  
정리하면, 프록시 객체를 초기화 할 때, 프록시 객체가 실제 엔티티로 바뀌는 것은 아니며, 초기화되면 프록시 객체를 통해서 실제 엔티티에 접근 가능이 가능합니다.  

<br>

**코드로 살펴보기**  
여기서 m1, m2는 모두 같은 프록시 객체에서 조회해 온 것을 의미합니다. 따라서 여기서는 동등비교(==)를 해도 ```true```가 나오는 것을 알 수 있습니다. 프록시 객체 타입을 비교할 때는 ```instanceOf```를 사용해야 합니다.  
```java
Member m1 = em.getReference(Member.class, "m1Id");
Member m2 = em.getReference(Member.class, "m1Id");
System.out.println(m1 == m2); // true
```
처음에는 프록시 객체를 생성하고, ```getName()``` 조회를 하는 순간, 영속성 컨텍스트에 초기화 요청으로 실제 객체를 참조하게 됩니다. 이후 같은 객체를 선언하는 ```m2```에는 실제 객체를 바로 조회하게 됩니다. 이미 영속성 컨텍스트에서 관리하는 객체이기 때문입니다.  
```java
Member m1 = em.getReference(Member.class, "m1Id");  // 프록시 객체
m1.getName(); // 초기화 요청
Member m2 = em.getReference(Member.class, "m1Id");  // 실제 객체
```

<br>

**LazyInitializationException**  
준영속 상태에서는 프록시를 초기화하면  hibernate는 ```org.hibernate.LazyInitializationException``` 예외가 발생할 수 있습니다. 이 문제는 스프링 ```@Transaction```을 사용하는 과정에서 발생하는데, 서비스단에서 받은 entity를 컨트롤러에서 mapper로 DTO 처리하는 과정에서 흔히 볼 수 있는 문제입니다. ```@Transaction```이 명시된 서비스단 메서드가 종료되면, 영속성 컨텍스트에서 그 객체를 관리하지 않기 때문에 실제 객체로 mapper 처리를 제대로 하지 못하는 문제가 발생하기 때문입니다. 스프링부트에서는 [Open Session In View](https://kingbbode.tistory.com/27)를 기본값으로 하고 있기 때문에 <span style="background-color:#fff5b1">영속성 컨텍스트를 뷰 렌더링이 끝나는 시점까지 개방한 상태로 유지</span>합니다.  

****
[자바 ORM 표준 JPA 프로그래밍 - 기본편](https://www.inflearn.com/course/ORM-JPA-Basic/dashboard)  
[Proxy Objects and Eager & Lazy Fetch Types in Hibernate](https://www.dineshonjava.com/hibernate/proxy-objects-and-eager-and-lazy-fetch/)  
[[JPA] 영속성 전이, 고아 객체 (cascade 범위)](https://sudo-minz.tistory.com/144)

<br><br>

## 데이터 타입
JPA 타입은 <span style="background-color:#fff5b1">엔티티 타입</span>(```@Entity``` 식별자로 인식)과 <span style="background-color:#fff5b1">값 타입</span>(식별자 없이 값만 있는 추적 불가능한 타입)으로 분류할 수 있습니다. 값 타입은 추적이 불가능하기 때문에 절대 공유되면 안됩니다. 즉, Interger, String 같은 공유가능한 주소값만 넘어가기 때문에 변경이 불가능합니다. JPA에서 값 타입의 종류로는 <span style="background-color:#fff5b1">기본값 타입, 임베디드 타입, 컬렉션 값 타입</span>이 있습니다.   
값 타입을 원시타입인 경우는 동일성 비교로 ```==```를 사용하면 되지만, 그 외에 임베디드 타입과 같은 값을 비교할 때는 ```equals()```를 사용해서 동등성 비교를 해야 합니다.  
<span style="background-color:#DCFFE4">immutable한 객체에 대해 더 자세히 알아보자!</span>  
Java에서 Integer나 String은 immutable한 객체입니다. 이러한 객체들은 공유 가능한 주소값만 넘어가기 때문에 변경이 불가능합니다. 예를 들어, Integer a = 5; 와 Integer b = a; 라는 코드가 있다면, a와 b는 같은 주소값을 공유하게 됩니다. 따라서 a나 b 중 하나를 변경하면 다른 하나도 함께 변경되는 것이 아니라, <span style="background-color:#fff5b1">새로운 객체가 생성</span>됩니다. JPA의 엔티티 일부로 사용될 수 있는 값 타입입니다.  

<br>

**임베디드 타입(복합 값 타입)**  
임베디드 타입도 엔티티 타입이 아니기 때문에 추적이 불가능합니다. Member 엔티티에서 Address 객체를 값 타입처럼 사용할 수 있습니다. ```@Embedded```으로 임베디드 타입의 값임을 명시하고, ```@Embeddable```로 클래스가 임베디드 타입임을 명시합니다. 현업에서는 주소나 연락처와 같이 엔티티에서 자주 사용되는 값들을 임베디드 타입으로 정의하여 사용합니다. 예를 들어, 회원(Member) 엔티티에서는 회원의 이름, 나이, 주소, 연락처 등이 자주 사용되는데, 이러한 값들을 임베디드 타입으로 정의하여 Member 엔티티에서 사용할 수 있습니다. 
값 타입을 별도의 테이블로 분리하여 저장하면 조인이 발생하므로 성능이 저하될 수 있습니다. 이러한 경우에도 임베디드 타입을 사용하면 Member 테이블과 함께 저장되므로 성능상 이점이 있습니다. 또한, 임베디드 타입을 사용하면 코드의 가독성이 좋아지고, 객체를 다루는 코드가 간결해집니다. 따라서 현업에서도 임베디드 타입을 자주 사용하는데, 이는 객체지향적인 설계를 할 수 있게 해주기 때문입니다.  
아래 코드로 보면, Address 객체를 따로 테이블로 만들지 않고 Member 테이블과 함께 개개의 컬럼으로 생성되어 저장됩니다.  
```java
@Entity
public class Member {
    @Id
    private Long id;
    private String name;
    @Embedded
    private Address address;
    // ...
}

@Embeddable
public class Address {
    private String city;
    private String street;
    private String zipcode;
    // ...
}
```
임베디드 타입에서 ```@Embeddable``` 객체를 공유 참조하는 경우, 그 객체를 사용하는 entity들에서 모두 변경이 발생하는 문제가 발생할 수 있습니다. 이 경우 추적이 어렵기 때문에 반드시 공유 참조를 하려는 대상을 불변객체로 생성해야 합니다. ```setter``` 메서드를 사용하지 않아야 하며, 변경할 필요가 있는 경우에는 새로운 객체를 다시 만들어서 값을 수정하는 방식이 안전합니다.  

[불변객체로 설정하지 않은 경우의 문제점]
```java
Address address = new Address("city", "street", "10000");

Member member1 = new Member();
member1.setName("member1");
member1.setHomeAddress(address);

Member member2 = new Member();
member2.setName("member2");
member2.setHomeAddress(address);

em.persist(member1);
em.persist(member2);

address.setCity("seoul"); 
// member1과 member2 모두 address의 city가 'seoul'로 변경됩니다.
```

[불변객체로 설정했을 때의 임베디드 타입의 값 변경]
```java
Address address = new Address("city", "street", "10000");

Member member1 = new Member();
member1.setName("member1");
member1.setHomeAddress(address);
em.persist(member1);
        
// 수정이 필요한 경우
Address newAddress = new Address("seoul", address.getStreet(), address.getZipcode());
member1.setHomeAddress(newAddress);
```

<br>

<span style="background-color:#DCFFE4">BaseEntity를 사용하면 되지 않을까?</span>  
여기서 이런 의문이 들었습니다. 공통 속성이라면 ```BaseEntity```로 관리하는 방법도 있는데, 컬럼에 대한 임베디드 값 타입으로 설정하는게 어떤 부분에서 크게 다른지 생각해봤습니다.  
```@Embedded```와 ```@Embeddable```을 사용하면 하나의 엔티티에서 여러 개의 값을 그룹화할 수 있습니다. 이렇게 그룹화된 값은 다른 엔티티에서도 재사용할 수 있습니다. 또한, 값 타입을 별도의 테이블로 분리하여 관리할 수 있기 때문에 데이터 일관성과 중복성을 줄일 수 있습니다.  
개념적인 부분에서도 ```BaseEntity```는 상속을 하는 개념으로 공통 컬럼들을 정의합니다. 하지만 ```@Embedded```를 이용하는건 주소라는 컬럼 내에 ```우편번호, 기본주소, 상세주소```와 같은 하나의 그룹화된 속성들을 지정한다는 점에서 차이가 있습니다. 결론적으로 <span style="background-color:#fff5b1">여러 엔티티의 공통 속성을 묶에서 관리하기 위해서는 상속 개념을 이용하는 것이 바람직하고, 하나의 속성을 세부 속성들을 그룹화해서 사용하기 좋은 것은 임베디드 값 타입을 사용하는 것이 적절합니다.</span> 

<br>

**컬렉션 값 타입**  
값 타입을 하나 이상 저장할 때 사용되며, 자바의 컬렉션을 사용합니다. <span style="background-color:#FFE6E6">값 타입 컬렉션은 ```CASCADE```를 기본값으로 갖고 있으며, 영속성 전에(Cascade) + 고아 객체 제거 기능을 필수로 가진다고 볼 수 있습니다. 만약 값 타입 컬렉션에 변경 사항이 발생하면, 주인 엔티티와 연관된 모든 데이터를 삭제하고, 값 타입 컬렉션에 있는 현재 값을 모두 다시 저장합니다.</span>   
```@ElementCollection```을 사용해서 컬렉션 타입을 사용할 수 있는데, 자동으로 부모 id를 기본키로 갖는 테이블이 ```member_roles```라는 테이블이 자동으로 생성됩니다. ```@CollectionTable```으로 컬렉션 값 타입에 사용될 테이블 속성을 명시적으로 지정해 줄 수 있습니다. 
```java
@Entity
public class Member {
    @Id
    @GeneratedValue
    @Column(name = "member_id")
    @Setter
    private Long id;
  
    @Column
    @ElementCollection
    private List<String> roles = new ArrayList<>();
    
    @ElementCollection 
    @CollectionTable(name="OPTIONS", joinColumns=@JoinColumn(name="MEMBER_ID")) 
    private List<String> options = new ArrayList<>();
}
```
컬렉션 값 타입은 지연로딩 전략을 사용하기 때문에 컬렉션 값 타입을 조회하는 등 필요한 순간에 쿼리가 생성됩니다. 
```java
Membmer member = em.find(Member.class, member.getId());  // member만 조회
member.getRols();  // 컬렉션 값 타입 조회
```
 
<br>

**JPA 타입에 대해 이것만은 알고가자!**    
1. 임베디드 타입을 컬렉션 값 타입으로 함께 혼용 사용할 수 있습니다. 
2. 현업에서는 컬렉션 값 타입이 아주 간단한 영역이 아닌 경우, ```일대다``` 또는 ```다대일``` 연관관계로 변경해서 사용해 엔티티 추적을 용이하게 사용합니다.
3. 추적이 불가능한 임베디드나 컬렉션 값 타입을 사용할 경우 반드시 ```불변객체```로 만들어서 사용해야 합니다.

****
[자바 ORM 표준 JPA 프로그래밍 - 기본편](https://www.inflearn.com/course/ORM-JPA-Basic/dashboard)  
[[JPA] 값 타입과 불변 객체 - 값 타입 (2)](https://ittrue.tistory.com/266)  
[[JPA] 값 타입 컬렉션 : @ElementCollection, @CollectionTable](https://developer-hm.tistory.com/48)  
[[Spring JPA] @Embedded, @Embeddable](https://velog.io/@seongwon97/Spring-Boot-JPA-Embedded-Embeddable)

<br><br>

## 
